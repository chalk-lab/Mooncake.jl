# Mooncake.jl Codebase - Comprehensive Conceptual Map

> **Documentation**: See docs/src/index.md for project overview, docs/src/tutorial.md for usage examples

## Quick Start Guide

### **First-Time Readers: Start Here**

If you're new to the codebase, read in this order:
1. **docs/src/understanding_mooncake/introduction.md** - Prerequisites and what AD is
2. **docs/src/understanding_mooncake/algorithmic_differentiation.md** - Math foundations (skim if familiar with AD)
3. **docs/src/understanding_mooncake/rule_system.md** - Core rule interface (critical!)
4. **src/tangents.jl:1-100** - Skim to understand tangent types
5. **src/fwds_rvs_data.jl:1-100** - Skim to understand fdata/rdata split
6. **Pick a task below** and follow the relevant reading path

### **Reading Paths by Goal**

#### **Goal: Use Mooncake.jl**
1. docs/src/tutorial.md - DifferentiationInterface.jl usage
2. docs/src/interface.md - Native API if DI.jl insufficient
3. docs/src/known_limitations.md - What doesn't work

#### **Goal: Debug an AD Issue**
1. docs/src/utilities/debugging_and_mwes.md - How to create MWEs
2. docs/src/utilities/debug_mode.md - Enable type checking
3. src/developer_tools.jl - Inspect generated IR
4. docs/src/developer_documentation/developer_tools.md - Using IR tools

#### **Goal: Add a Primitive Rule**
1. docs/src/utilities/defining_rules.md - Complete guide
2. docs/src/understanding_mooncake/rule_system.md - Rule interface
3. Look at similar rule in src/rrules/ for pattern
4. src/test_utils.jl - Use `test_rule` for testing

#### **Goal: Support a Custom Type**
1. docs/src/developer_documentation/custom_tangent_type.md - Complete guide
2. src/tangents.jl:302-496 - See default tangent_type implementation
3. ext/MooncakeDynamicExpressionsExt.jl - Complex real-world example
4. src/test_utils.jl - Use `test_data` for verification

#### **Goal: Understand How AD Works Internally**
1. docs/src/understanding_mooncake/algorithmic_differentiation.md - Math
2. docs/src/developer_documentation/reverse_mode_design.md - Compilation overview
3. docs/src/developer_documentation/ir_representation.md - IR basics
4. src/interpreter/reverse_mode.jl:1152-1196 - Read `generate_ir`
5. src/interpreter/reverse_mode.jl:394-861 - Read `make_ad_stmts!` for one statement type

#### **Goal: Fix a Performance Issue**
1. Profile to identify bottleneck
2. src/developer_tools.jl - Inspect generated IR
3. src/rrules/performance_patches.jl - See example performance rule
4. Consider adding primitive to DefaultCtx (not MinimalCtx)

## Glossary of Terms

| Term | Meaning | Location |
|------|---------|----------|
| **Primal** | Original computation being differentiated | Throughout |
| **Tangent** | Derivative information; input/output of `D f[x]` | src/tangents.jl:1-1426 |
| **Cotangent** | Adjoint/gradient information; input/output of `D f[x]*` | Throughout |
| **CoDual** | Pairs primal with fdata for reverse-mode | src/codual.jl:1-124 |
| **Dual** | Pairs primal with tangent for forward-mode | src/dual.jl:1-58 |
| **FData** | Forward data - mutable components of tangent | src/fwds_rvs_data.jl |
| **RData** | Reverse data - immutable components of tangent | src/fwds_rvs_data.jl |
| **Rule** | Function that computes AD (hand-written or derived) | Throughout |
| **Primitive** | Function with hand-written rule | src/interpreter/contexts.jl |
| **Derived Rule** | Auto-generated rule from IR transformation | src/interpreter/reverse_mode.jl |
| **Pullback** | Reverse-pass function that propagates gradients | Throughout |
| **IRCode** | Julia's SSA intermediate representation | Core.Compiler |
| **BBCode** | Mooncake's basic-block IR representation | src/interpreter/bbcode.jl |
| **SSA** | Static Single Assignment - each variable assigned once | Throughout |
| **PhiNode** | Merges values from different control flow paths | IR nodes |
| **Block Stack** | Tracks which blocks were visited (reverse-mode) | src/interpreter/reverse_mode.jl:81 |
| **Activity Analysis** | Determining what's differentiable vs constant | Implicit throughout |
| **SROA** | Scalar Replacement of Aggregates - compiler optimization | Julia compiler |

## Data Flow Overview

### **Reverse-Mode: value_and_gradient!! Call Chain**

```
User calls: value_and_gradient!!(rule, f, x...)
             ↓
interface.jl:169 → __value_and_gradient!!(rule, CoDual(f, tangent(f)), CoDual(x, tangent(x))...)
             ↓
interface.jl:104 → rule(map(to_fwds, coduals)...)  # to_fwds extracts fdata
             ↓
FORWARD PASS (generated by build_rrule):
  DerivedRule.fwds_oc(args...) runs, executing:
    - Extract shared data from captures
    - Create rdata Refs (optimized away by SROA)
    - Run transformed statements (rrule!! calls)
    - Push to block stack when needed
    - Push intermediate values to communication stacks
    - Return: CoDual(result, fdata), pullback
             ↓
interface.jl:110 → pullback(one(result))  # or pullback(rdata(ȳ))
             ↓
REVERSE PASS (generated by build_rrule):
  Pullback.pb_oc(dy) runs, executing:
    - Pop communication stacks
    - Pop block stack to determine control flow
    - Run transformed statements in reverse
    - Increment rdata Refs
    - Return: tuple of rdata for all arguments
             ↓
interface.jl:110 → tangent(fdata, rdata) for each argument
             ↓
Return: (value, (NoTangent(), gradient_x1, gradient_x2, ...))
```

### **Where Time is Spent (Performance Model)**

1. **First call**: Rule compilation dominates (~90%+ of time)
   - `build_rrule` generates and optimizes IR
   - Stored in `interp.oc_cache` for reuse

2. **Subsequent calls**: Execution time depends on:
   - **Primitives** (~fast) - Hand-written rules are typically well-optimized
   - **Block stack ops** (~10-30% overhead) - Reduced via unique predecessor optimization
   - **Communication stacks** (~5-15% overhead) - Reduced via SingletonStack optimization
   - **Memory operations** (~fast) - SROA eliminates most Ref allocations

3. **Slowest operations** (in derived rules):
   - Dynamic dispatch (`DynamicDerivedRule`)
   - Type-unstable code
   - Lots of small functions without primitives
   - Large loops with value-dependent control flow

## Critical Files (Read These First)

### **Core Type System (Essential)**
1. **src/tangents.jl** - Tangent type system (~1400 lines, skim structure)
   - Lines 1-100: Type definitions
   - Lines 302-496: `tangent_type` implementation
   - Lines 508-605: `zero_tangent_internal` implementation

2. **src/fwds_rvs_data.jl** - FData/RData split (~1000 lines, skim)
   - Lines 1-100: FData/RData type definitions
   - Lines 155-202: `fdata_type` implementation
   - Lines 433-476: `rdata_type` implementation

3. **src/codual.jl** - CoDual type (~120 lines, read fully)

### **Rule System (Essential)**
4. **src/interface.jl** - Public API (read lines 1-200 fully)
   - Understanding `value_and_gradient!!` flow is critical

5. **src/interpreter/contexts.jl** - What makes something primitive (~120 lines, read fully)

### **Rule Derivation (Important)**
6. **src/interpreter/reverse_mode.jl** - Read selectively:
   - Lines 1-200: Data structures (SharedDataPairs, ADInfo, etc.)
   - Lines 394-500: `make_ad_stmts!` for one example (e.g., ReturnNode)
   - Lines 1044-1196: `build_rrule` and `generate_ir` flow

7. **src/interpreter/bbcode.jl** - BBCode representation (skim if working on IR)

### **Example Rules (Learn by Example)**
8. **src/rrules/low_level_maths.jl** - Simple rules (read lines 1-200)
9. **src/rrules/blas.jl** - Complex rules (read one example, e.g., gemm!)
10. **src/rrules/builtins.jl** - Essential primitives (skim IntrinsicsWrappers module)

## 1. **Core Architecture**

### **Main Entry Point**
- **src/Mooncake.jl:1-172** - Module definition, includes all submodules, defines core functions (`frule!!`, `rrule!!`, `build_primitive_rrule`)
- **Documentation**: docs/src/index.md (getting started), docs/src/tutorial.md (DifferentiationInterface.jl usage)

### **Type System Hierarchy**

#### **Primal-Tangent Pairing**
- **src/dual.jl:1-58** - `Dual{P,T}` for forward-mode (primal + tangent)
- **src/codual.jl:1-124** - `CoDual{Tx,Tdx}` for reverse-mode (primal + fdata)

#### **Tangent Types**
- **src/tangents.jl:1-1426** - Core tangent system:
  - `NoTangent` - for non-differentiable types
  - `Tangent{NamedTuple}` - for immutable structs
  - `MutableTangent{NamedTuple}` - for mutable structs
  - `PossiblyUninitTangent{T}` - for potentially undefined fields
  - Functions: `tangent_type`, `zero_tangent`, `randn_tangent`, `increment!!`, `set_to_zero!!`

#### **FData/RData Splitting**
- **src/fwds_rvs_data.jl:1-1026** - Separates tangents into:
  - **FData** (forward data) - mutable/address-identified components, propagated on forward pass
  - **RData** (reverse data) - immutable/value-identified components, propagated on reverse pass
  - Key functions: `fdata_type`, `rdata_type`, `fdata`, `rdata`, `tangent(f, r)`
  - `ZeroRData` handling in **src/interpreter/zero_like_rdata.jl:1-40**
- **Documentation**: docs/src/understanding_mooncake/rule_system.md - "Representing Gradients" section explains fdata/rdata design

## 2. **Rule System**

> **Documentation**: docs/src/understanding_mooncake/rule_system.md - complete rule interface specification

### **Rule Interface**
- **rrule!! signature**: `(::CoDual{typeof(f)}, args::CoDual...) -> (CoDual{output}, pullback_function)`
- **frule!! signature**: `(::Dual{typeof(f)}, args::Dual...) -> Dual{output}`
- **Documentation**:
  - docs/src/understanding_mooncake/rule_system.md - "The Rule Interface" sections
  - docs/src/utilities/defining_rules.md - how to write custom rules

### **Primitive Rules** (src/rrules/)
Hand-written rules for Julia primitives:

| Category | File | Key Functions |
|----------|------|---------------|
| **Builtins** | src/rrules/builtins.jl:1-1000+ | `getfield`, `setfield!`, `tuple`, `===`, `isa`, `typeof`, `svec`, `ifelse` |
| **Intrinsics** | Module `IntrinsicsWrappers` in builtins.jl | `add_float`, `mul_float`, `div_float`, `neg_float`, `sqrt_llvm`, `fma_float`, `bitcast` |
| **Foreign calls** | src/rrules/foreigncall.jl:1-473 | `_foreigncall_`, `pointer_from_objref`, `unsafe_pointer_to_objref`, `unsafe_copyto!` |
| **Construction** | src/rrules/new.jl:1-212 | `_new_` (all object construction), `_splat_new_` |
| **Arrays (1.10)** | src/rrules/array_legacy.jl:1-666 | `arrayref`, `arrayset`, `_deletebeg!`, `_deleteend!`, `_growend!` |
| **Memory (1.11+)** | src/rrules/memory.jl:1-1000+ | `Memory`, `MemoryRef`, `memoryrefget`, `memoryrefset!`, `Array` construction |
| **BLAS** | src/rrules/blas.jl:1-1000+ | `gemm!`, `gemv!`, `symm!`, `symv!`, `trmv!`, `dot`, `nrm2`, `scal!`, `syrk!` |
| **LAPACK** | src/rrules/lapack.jl:1-643 | `getrf!`, `getrs!`, `getri!`, `trtrs!`, `potrf!`, `potrs!` |
| **Linear Algebra** | src/rrules/linear_algebra.jl:1-52 | `exp(::Matrix)` |
| **Low-level Math** | src/rrules/low_level_maths.jl:1-305 | `exp`, `log`, `sin`, `cos`, `tan`, `sqrt`, `cbrt`, `hypot`, etc. |
| **FastMath** | src/rrules/fastmath.jl:1-162 | Fast versions of math functions |
| **TwicePrecision** | src/rrules/twice_precision.jl:1-524 | `TwicePrecision`, `StepRangeLen`, range operations |
| **Random** | src/rrules/random.jl:1-84 | `randn`, `randexp`, `MersenneTwister` |
| **Tasks** | src/rrules/tasks.jl:1-146 | `Task`, `current_task` (limited support) |
| **IdDict** | src/rrules/iddict.jl:1-247 | `IdDict` operations |
| **MistyClosure** | src/rrules/misty_closures.jl:1-162 | Differentiation of closures with captured variables |
| **Performance** | src/rrules/performance_patches.jl:1-72 | Optimized `sum` for arrays |
| **Misc** | src/rrules/misc.jl:1-398 | `lgetfield`, `lsetfield!`, logging, string ops |
| **Avoidance** | src/rrules/avoiding_non_differentiable_code.jl:1-225 | Pointer arithmetic, logging macros, `@zero_derivative` rules |

### **Rule Derivation** (Automatic Differentiation)

> **Documentation**:
> - docs/src/developer_documentation/forwards_mode_design.md - forward-mode internals (planned)
> - docs/src/developer_documentation/reverse_mode_design.md - reverse-mode compilation process
> - docs/src/understanding_mooncake/algorithmic_differentiation.md - mathematical foundations

#### **Forward Mode**
- **src/interpreter/forward_mode.jl:1-507** - Derives `frule!!` from IR:
  - `build_frule` - main entry point
  - `generate_dual_ir` - transforms IR to compute derivatives
  - `DerivedFRule` - wrapper for derived forward rules
  - `LazyFRule` - lazy rule construction
  - `DynamicFRule` - dynamic dispatch
- **Documentation**: docs/src/developer_documentation/forwards_mode_design.md - detailed design document

#### **Reverse Mode**
- **src/interpreter/reverse_mode.jl:1-1875** - Derives `rrule!!` from IR:
  - `build_rrule` - main entry point (reverse_mode.jl:1044-1144)
  - `generate_ir` - creates forward + reverse IR (reverse_mode.jl:1152-1196)
  - `make_ad_stmts!` - transforms each IR statement (reverse_mode.jl:394-861)
  - `DerivedRule` - wrapper for derived reverse rules (reverse_mode.jl:934-960)
  - `Pullback` - callable that runs reverse pass (reverse_mode.jl:918-932)
  - `LazyDerivedRule` - lazy rule construction (reverse_mode.jl:1816-1842)
  - `DynamicDerivedRule` - dynamic dispatch (reverse_mode.jl:1726-1752)
  - `SharedDataPairs` - manages captured data (reverse_mode.jl:13-72)
  - `ADInfo` - global context for rule derivation (reverse_mode.jl:123-206)
  - `BlockStack` - tracks control flow (reverse_mode.jl:81)
- **Documentation**:
  - docs/src/developer_documentation/reverse_mode_design.md - compilation overview
  - docs/src/understanding_mooncake/algorithmic_differentiation.md - "Reverse-Mode AD: how does it do it?"

## 3. **IR Manipulation**

> **Documentation**: docs/src/developer_documentation/ir_representation.md - comprehensive guide to IRCode vs BBCode

### **IR Representations**
- **src/interpreter/bbcode.jl:1-1010** - `BBCode` data structure:
  - `BBlock` - basic block with unique IDs (bbcode.jl:194-265)
  - `ID` - unique identifier for blocks/statements (bbcode.jl:79-86)
  - `IDPhiNode`, `IDGotoNode`, `IDGotoIfNot` - ID-based control flow (bbcode.jl:108-138)
  - `Switch` - multi-way branch statement (bbcode.jl:160-168)
  - Conversion: `BBCode(::IRCode)` and `IRCode(::BBCode)` (bbcode.jl:528-657)
- **Documentation**: docs/src/developer_documentation/ir_representation.md
  - Julia's SSA-form IR explanation
  - Control flow and PhiNodes
  - Code transformation examples (replacing instructions, inserting blocks)
  - When to use IRCode vs BBCode

### **IR Utilities**
- **src/interpreter/ir_utils.jl:1-334** - IR manipulation:
  - `stmt` - get statement from IR (ir_utils.jl:9)
  - `set_stmt!`, `get_ir`, `set_ir!`, `replace_call!` (ir_utils.jl:18-36)
  - `ircode` - construct IRCode for testing (ir_utils.jl:56-65)
  - `infer_ir!` - run type inference (ir_utils.jl:101-126)
  - `optimise_ir!` - optimization pipeline (ir_utils.jl:146-188)
  - `lookup_ir` - get IR from signature/MethodInstance (ir_utils.jl:206-254)

### **IR Normalization**
- **src/interpreter/ir_normalisation.jl:1-495** - Standardize IR:
  - `normalise!` - main entry (ir_normalisation.jl:23-44)
  - `foreigncall_to_call` - `:foreigncall` → `_foreigncall_()` call (ir_normalisation.jl:144-158)
  - `new_to_call` - `:new` → `_new_()` call (ir_normalisation.jl:218)
  - `splatnew_to_call` - `:splatnew` → `_splat_new_()` call (ir_normalisation.jl:229)
  - `intrinsic_to_function` - intrinsics → `IntrinsicsWrappers` (ir_normalisation.jl:244-256)
  - `lift_getfield_and_others` - constant field access → `lgetfield` (ir_normalisation.jl:267-290)
  - `lift_gc_preservation` - GC preservation handling (ir_normalisation.jl:403-407)
  - `const_prop_gotoifnots!` - constant propagation for branches (ir_normalisation.jl:416-432)

### **Compiler Integration**
- **src/interpreter/abstract_interpretation.jl:1-223** - Custom interpreter:
  - `MooncakeInterpreter{C,M}` - subtype of `AbstractInterpreter` (abstract_interpretation.jl:27-66)
  - `ClosureCacheKey` - cache key for closures (abstract_interpretation.jl:13-16)
  - `inlining_policy` - prevents primitive inlining (abstract_interpretation.jl:159-196)
  - `get_interpreter` - returns cached interpreter (abstract_interpretation.jl:217-222)
  - `GLOBAL_INTERPRETERS` - cached interpreters (abstract_interpretation.jl:204-207)
- **Documentation**: docs/src/developer_documentation/reverse_mode_design.md - explains `MooncakeInterpreter` role

### **Contexts**
- **src/interpreter/contexts.jl:1-119** - AD contexts:
  - `MinimalCtx` - only essential primitives (contexts.jl:8)
  - `DefaultCtx` - all performance primitives (contexts.jl:17)
  - `ForwardMode`, `ReverseMode` - AD mode markers (contexts.jl:32, 39)
  - `is_primitive` - determines if function is primitive (contexts.jl:58-61)
  - `@is_primitive` - macro to declare primitives (contexts.jl:69-118)
- **Documentation**: docs/src/developer_documentation/reverse_mode_design.md - distinction between MinimalCtx and DefaultCtx

### **Compiler Patches**
- **src/interpreter/patch_for_319.jl:1-435** - Workarounds for Julia compiler bugs (issue #319)

## 4. **Public Interface**

> **Documentation**: docs/src/interface.md - complete public API reference

- **src/interface.jl:1-588** - User-facing API:
  - `value_and_gradient!!(rule, f, x...)` - compute gradient (interface.jl:169-171)
  - `value_and_pullback!!(rule, ȳ, f, x...)` - compute pullback (interface.jl:142-144)
  - `value_and_derivative!!(rule, f, x...)` - forward-mode (interface.jl:581)
  - `prepare_gradient_cache` - pre-compile for performance (interface.jl:515-522)
  - `prepare_pullback_cache` - pre-compile for pullback (interface.jl:439-458)
  - `prepare_derivative_cache` - pre-compile for forward-mode (interface.jl:572)
  - `__value_and_gradient!!`, `__value_and_pullback!!` - lower-level internal versions
- **Documentation**:
  - docs/src/interface.md - public API docstrings
  - docs/src/tutorial.md - usage examples with DifferentiationInterface.jl

- **src/config.jl:1-18** - Configuration:
  - `Config(; debug_mode, silence_debug_messages)`
- **Documentation**: docs/src/utilities/debug_mode.md - when and how to use debug mode

- **src/public.jl:1-15** - Public API macro for Julia 1.11+

## 5. **Utilities & Tools**

### **Rule Definition Helpers**
- **src/tools_for_rules.jl:1-698** - Macros and utilities:
  - `@mooncake_overlay` - override function for AD (tools_for_rules.jl:104-112)
  - `@zero_derivative` - mark functions with zero derivative (tools_for_rules.jl:248-302)
  - `@zero_adjoint` - reverse-mode specific (tools_for_rules.jl:310-312)
  - `@from_chainrules` - import ChainRules rrules (tools_for_rules.jl:628-687)
  - `@from_rrule` - import specific rrule (tools_for_rules.jl:695-697)
  - `zero_adjoint`, `zero_derivative` - function versions (tools_for_rules.jl:148-177)
  - `to_cr_tangent`, `mooncake_tangent` - ChainRules conversion (tools_for_rules.jl:323-373)
- **Documentation**: docs/src/utilities/defining_rules.md
  - Complete guide to all rule-writing strategies
  - `@mooncake_overlay` examples
  - `@zero_adjoint` usage
  - `@from_rrule` / `@from_chainrules` with worked examples
  - When to implement custom `rrule!!`

### **Testing Infrastructure**
- **src/test_utils.jl:1-1680** - Comprehensive testing:
  - `test_rule` - main testing function (test_utils.jl:895-986)
  - `test_tangent_interface` - test tangent operations (test_utils.jl:1111-1233)
  - `test_tangent_splitting` - test fdata/rdata split (test_utils.jl:1439-1522)
  - `test_rule_and_type_interactions` - test primitives work (test_utils.jl:1553-1580)
  - `test_data` - combined test (test_utils.jl:1672-1677)
  - `has_equal_data` - structural equality (test_utils.jl:201-327)
  - `populate_address_map` - track aliasing (test_utils.jl:338-414)
- **Documentation**:
  - docs/src/utilities/debugging_and_mwes.md - using `test_rule` for debugging
  - docs/src/developer_documentation/tangents.md - testing functions explained
  - docs/src/developer_documentation/running_tests_locally.md - local testing workflow

- **src/test_resources.jl:1-995** - Test data:
  - Module `TestResources` with test types (test_resources.jl:8-989)
  - `generate_test_functions` - standard test cases (test_resources.jl:699-929)
  - Test types: `StructFoo`, `MutableFoo`, `TypeStableMutableStruct`, etc.

### **Developer Tools**
- **src/developer_tools.jl:1-155** - IR inspection:
  - `primal_ir` - get primal IR (developer_tools.jl:22-24)
  - `dual_ir` - get forward-mode IR (developer_tools.jl:61-68)
  - `fwd_ir` - get forward pass IR (developer_tools.jl:104-111)
  - `rvs_ir` - get reverse pass IR (developer_tools.jl:147-154)
- **Documentation**: docs/src/developer_documentation/developer_tools.md - IR inspection guide

### **General Utilities**
- **src/utils.jl:1-457** - Helper functions:
  - `_typeof` - stable typeof (utils.jl:6-8)
  - `tuple_map` - specialized tuple mapping (utils.jl:26-50)
  - `always_initialised` - field initialization info (utils.jl:218-222)
  - `lgetfield` - literal getfield with `Val` (utils.jl:250)
  - `lsetfield!` - literal setfield with `Val` (utils.jl:261)
  - `_new_` - direct `:new` instruction (utils.jl:268-270)
  - `opaque_closure`, `misty_closure` - closure construction (utils.jl:326-367)

### **Data Structures**
- **src/stack.jl:1-40** - Specialized stack:
  - `Stack{T}` - never-deallocating stack for reverse pass (stack.jl:8-34)
  - `SingletonStack{T}` - zero-overhead singleton stack (stack.jl:36-39)

### **Debug Mode**
- **src/debug_mode.jl:1-124** - Runtime type checking:
  - `DebugRRule` - wraps rules with type checks (debug_mode.jl:77-95)
  - `DebugPullback` - wraps pullbacks with type checks (debug_mode.jl:14-31)
  - `DebugFRule` - forward-mode equivalent (debug_mode.jl:2)
- **Documentation**: docs/src/utilities/debug_mode.md
  - When to use debug mode
  - How it catches type errors
  - Performance implications

## 6. **Extensions** (ext/)

| Extension | Purpose | Key Types/Functions |
|-----------|---------|---------------------|
| **MooncakeCUDAExt.jl** | CUDA support | `CuArray` tangent ops, allocation rules |
| **MooncakeAllocCheckExt.jl** | Allocation checking | `check_allocs_internal` |
| **MooncakeJETExt.jl** | Type stability | `test_opt_internal`, `report_opt_internal` |
| **MooncakeLuxLibExt.jl** | LuxLib ops | `matmul`, `conv`, `batchnorm` overlays |
| **MooncakeLuxLibSLEEFPiratesExtension.jl** | Fast activations | `sigmoid_fast`, `tanh_fast`, etc. |
| **MooncakeNNlibExt.jl** | NNlib ops | `conv`, `pooling`, `dropout`, `softmax` |
| **MooncakeSpecialFunctionsExt.jl** | Special functions | Bessel, gamma, erf functions via ChainRules |
| **MooncakeFluxExt.jl** | Flux support | Optimized `mse` loss |
| **MooncakeFunctionWrappersExt.jl** | FunctionWrapper | Custom tangent with AD through wrapper |
| **MooncakeDynamicExpressionsExt.jl** | Symbolic expressions | `TangentNode` for expression trees |

## 7. **Key Algorithms & Concepts**

### **Forward-Mode AD Workflow**
1. `build_frule(sig)` → generates rule
2. `lookup_ir` → get primal IR
3. `normalise!` → standardize IR
4. Transform each statement: Arguments+1, wrap in `Dual`, replace calls with `frule!!`
5. `optimise_ir!` → optimize generated IR
6. Wrap in `MistyClosure` → `DerivedFRule`

### **Reverse-Mode AD Workflow**
1. `build_rrule(sig)` → generates rule
2. `lookup_ir` → get primal IR
3. `normalise!` → standardize IR
4. `BBCode(ir)` → convert to basic block form
5. `ADInfo` construction → setup metadata
6. `make_ad_stmts!` → transform each statement into forward/reverse instructions
7. `forwards_pass_ir` → generate forward pass (reverse_mode.jl:1294-1356)
8. `pullback_ir` → generate reverse pass (reverse_mode.jl:1376-1523)
9. `optimise_ir!` → optimize both passes
10. Wrap in `MistyClosure`s → `DerivedRule` + `Pullback`

### **Critical Implementation Details**

**Block Stack** (reverse_mode.jl:81):
- Tracks which blocks were visited during forward pass
- Used to determine control flow on reverse pass
- Optimized away for unique predecessors

**Shared Data** (reverse_mode.jl:13-72):
- Data shared between forward/reverse passes
- Stored in `OpaqueClosure` captures
- Contains block stack, communication stacks, lazy zero rdata

**Communication Channels** (reverse_mode.jl:1251-1287):
- Per-block stacks storing intermediate values
- Push on forward pass, pop on reverse pass
- Optimized to `SingletonStack` when possible

**RData Refs** (reverse_mode.jl:259-273):
- Each SSA/Argument gets a `Ref` to accumulate gradients
- Initialized to zero, incremented during reverse pass
- Optimized away by SROA pass

## 8. **File Organization Summary**

```
Mooncake.jl/
├── src/
│   ├── Mooncake.jl              # Main module
│   ├── tangents.jl              # Tangent type system
│   ├── fwds_rvs_data.jl         # FData/RData splitting
│   ├── dual.jl                  # Forward-mode Dual type
│   ├── codual.jl                # Reverse-mode CoDual type
│   ├── interface.jl             # Public API
│   ├── config.jl                # Configuration
│   ├── debug_mode.jl            # Runtime type checking
│   ├── stack.jl                 # Block stack
│   ├── utils.jl                 # General utilities
│   ├── tools_for_rules.jl       # Rule definition macros
│   ├── test_utils.jl            # Testing infrastructure
│   ├── test_resources.jl        # Test data
│   ├── developer_tools.jl       # IR inspection tools
│   ├── public.jl                # Public API declarations
│   ├── interpreter/
│   │   ├── contexts.jl          # AD contexts
│   │   ├── abstract_interpretation.jl  # Custom interpreter
│   │   ├── bbcode.jl            # BBCode IR representation
│   │   ├── ir_utils.jl          # IR manipulation
│   │   ├── ir_normalisation.jl  # IR standardization
│   │   ├── forward_mode.jl      # Forward-mode derivation
│   │   ├── reverse_mode.jl      # Reverse-mode derivation
│   │   ├── zero_like_rdata.jl   # ZeroRData utilities
│   │   └── patch_for_319.jl     # Compiler bug workarounds
│   └── rrules/
│       ├── builtins.jl          # Core built-in functions
│       ├── foreigncall.jl       # ccall handling
│       ├── new.jl               # Object construction
│       ├── misc.jl              # lgetfield, lsetfield!, etc.
│       ├── blas.jl              # BLAS operations
│       ├── lapack.jl            # LAPACK operations
│       ├── linear_algebra.jl    # High-level LinAlg
│       ├── low_level_maths.jl   # Math functions
│       ├── fastmath.jl          # FastMath functions
│       ├── array_legacy.jl      # Array ops (1.10)
│       ├── memory.jl            # Memory/Array ops (1.11+)
│       ├── random.jl            # Random number generation
│       ├── twice_precision.jl   # TwicePrecision/ranges
│       ├── tasks.jl             # Task (limited)
│       ├── iddict.jl            # IdDict operations
│       ├── misty_closures.jl    # Closure differentiation
│       ├── performance_patches.jl  # Performance optimizations
│       ├── avoiding_non_differentiable_code.jl  # Zero derivative rules
│       └── dispatch_doctor.jl   # DispatchDoctor integration
├── ext/                         # Package extensions
├── test/                        # Test suite (mirrors src/)
└── docs/                        # Documentation
```

## 9. **Documentation Structure** (docs/src/)

### **User-Facing**
- `index.md` - Project overview, getting started, project status
- `tutorial.md` - DifferentiationInterface.jl and native API usage
- `interface.md` - Public API documentation
- `known_limitations.md` - Mutation of globals, recursive types, pointers

### **Understanding Mooncake**
- `understanding_mooncake/introduction.md` - Prerequisites, who docs are for
- `understanding_mooncake/algorithmic_differentiation.md` - Mathematical foundations
  - Fréchet derivatives, adjoints, tangents
  - Forward vs reverse mode
  - Gradients and directional derivatives
- `understanding_mooncake/rule_system.md` - Core rule interface
  - `rrule!!` specification
  - CoDual, fdata/rdata system
  - Testing with `test_rule`

### **Utilities**
- `utilities/defining_rules.md` - How to write rules
  - `@mooncake_overlay` - code simplification
  - `@zero_adjoint` - zero derivative functions
  - `@from_rrule` - import ChainRules
  - Adding custom `rrule!!` methods
- `utilities/debug_mode.md` - `DebugRRule` for type checking
- `utilities/debugging_and_mwes.md` - Using `TestUtils.test_rule`

### **Developer Documentation**
- `developer_documentation/running_tests_locally.md` - Test workflow with Revise.jl
- `developer_documentation/developer_tools.md` - IR inspection tools
- `developer_documentation/tangents.md` - Tangent type interface requirements
- `developer_documentation/custom_tangent_type.md` - Detailed guide for recursive types
  - Complete worked example with `struct A` containing self-reference
  - All required methods: `zero_tangent_internal`, `randn_tangent_internal`, `increment_internal!!`, etc.
- `developer_documentation/ir_representation.md` - IRCode vs BBCode
  - SSA-form IR explanation
  - Control flow and PhiNodes
  - Code transformation examples
- `developer_documentation/forwards_mode_design.md` - Forward-mode AD design (unimplemented)
- `developer_documentation/reverse_mode_design.md` - Compilation process overview
- `developer_documentation/misc_internals_notes.md` - Implementation notes
  - `tangent_type` generated function design
  - Recursion handling via `LazyDerivedRule`

## 10. **Testing** (test/)

### **Test Organization**
- **test/front_matter.jl:1-163** - Common test setup, determines test group
- **test/runtests.jl:1-71** - Main test runner with group selection
- **test/run_extra.jl:1-4** - Integration test runner

### **Test Files** (mirror src/)
- `test/tangents.jl` - Tangent type tests
- `test/codual.jl` - CoDual tests
- `test/interface.jl` - Public API tests
- `test/rrules/*.jl` - Tests for each rrules file
- `test/interpreter/*.jl` - Tests for interpreter components
- `test/integration_testing/` - Integration with other packages
- `test/ext/` - Extension tests

## 11. **Worked Example: Tracing a Simple Gradient**

Let's trace `value_and_gradient!!(rule, f, x)` where `f(x) = sin(x)` and `x = 5.0`:

### **Preparation** (one-time cost)
```julia
rule = build_rrule(f, 5.0)  # In src/interpreter/reverse_mode.jl:1044
```
1. `lookup_ir` gets IR for `f(::Float64)` → finds `sin` call
2. `is_primitive(DefaultCtx, ReverseMode, Tuple{typeof(sin), Float64})` → `true` (from low_level_maths.jl)
3. Since it's primitive, `build_rrule` returns `rrule!!` directly (no IR transformation needed)

### **Execution** (fast, repeated calls)
```julia
value_and_gradient!!(rule, f, 5.0)  # In src/interface.jl:169
```
1. Creates `CoDual(f, NoTangent())` and `CoDual(5.0, 0.0)` (zero tangent)
2. Calls `rule(to_fwds(coduals)...)` → `rrule!!(CoDual(f, NoFData()), CoDual(5.0, NoFData()))`
3. **Forward pass** (in src/rrules/low_level_maths.jl):
   - Computes `y = sin(5.0) = -0.9589...`
   - Returns `CoDual(-0.9589, NoFData())` and pullback closure
4. **Reverse pass** - calls `pullback(1.0)`:
   - Computes `∂x = cos(5.0) * 1.0 = 0.2836...`
   - Returns `(NoRData(), 0.2836...)`
5. Reconstructs result: `(-0.9589, (NoTangent(), 0.2836))`

### **Worked Example: Derived Rule**

For `g(x) = sin(cos(x))` with `x = 5.0`:

**build_rrule generates**:
```julia
# Forward pass IR (simplified):
%1 = rrule!!(zero_fcodual(cos), CoDual(x, NoFData()))  # y=%1[1], pb_cos=%1[2]
%2 = rrule!!(zero_fcodual(sin), %1[1])                 # result=%2[1], pb_sin=%2[2]
push!(comms_stack, %1[2])  # Store cos's pullback
push!(comms_stack, %2[2])  # Store sin's pullback
return %2[1]  # Return CoDual(sin(cos(x)), NoFData())

# Reverse pass IR (simplified):
pb_sin = pop!(comms_stack)
pb_cos = pop!(comms_stack)
dy_inner = pb_sin(dy)      # dy w.r.t cos(x)
dx = pb_cos(dy_inner[2])   # dy w.r.t x
return (NoRData(), dx[2])  # (df, dx)
```

## 12. **Key Concepts & Terminology**

> **Documentation**: docs/src/understanding_mooncake/algorithmic_differentiation.md - complete mathematical treatment

### **Mathematical Foundation**
- **Fréchet Derivative**: Linear operator `D f[x] : X → Y` satisfying `df = D f[x](dx)`
- **Adjoint**: Linear operator `D f[x]* : Y → X` satisfying `⟨D f[x]*(ȳ), ẋ⟩ = ⟨ȳ, D f[x](ẋ)⟩`
- **Tangent**: Input/output of derivatives (denoted with dot: `ẋ`, `ẏ`)
- **Cotangent/Gradient**: Input/output of adjoints (denoted with bar: `x̄`, `ȳ`)
- **Documentation**: docs/src/understanding_mooncake/algorithmic_differentiation.md
  - Derivatives section - scalar to general Hilbert spaces
  - Worked examples with matrices and mutable data
  - Chain rule and how forward/reverse mode work
  - Directional derivatives and gradients

### **Implementation Details**
- **Primitive**: Function with hand-written rule, not derived from IR
- **Derived Rule**: Rule automatically generated from IR transformation
- **Activity Analysis**: Distinguishing differentiable from non-differentiable data
- **Unique Predecessor**: Block with only one possible incoming edge (optimization opportunity)
- **Lazy Rule Construction**: Defer rule compilation until first use (handles recursion)
- **Dynamic Dispatch**: Runtime rule selection based on argument types
- **Static Dispatch**: Compile-time rule selection via `:invoke` nodes

### **Performance Optimizations**
1. **SROA** (Scalar Replacement of Aggregates) - eliminates `Ref` allocations
2. **Singleton Type Optimization** - avoids storing singleton pullbacks
3. **Block Stack Elimination** - skips block tracking for unique predecessors
4. **Constant Propagation** - folds constants, eliminates dead branches
5. **Lazy Zero RData** - defers zero construction until needed

## 13. **Common Patterns & Idioms**

### **Pattern: Accessing Rule-Generated IR**
```julia
# See what IR Mooncake generates:
using Mooncake: get_interpreter, ReverseMode, primal_ir, fwd_ir, rvs_ir

sig = Tuple{typeof(sin), Float64}
interp = get_interpreter(ReverseMode)

primal_ir(interp, sig)  # Original function IR
fwd_ir(sig)             # Forward pass IR
rvs_ir(sig)             # Reverse pass IR (pullback)
```

### **Pattern: CoDual Construction**
```julia
# Manual CoDual construction (rarely needed):
x = [1.0, 2.0, 3.0]
dx = zero_tangent(x)  # Create tangent
codual = CoDual(x, fdata(dx))  # Pair primal with fdata

# Usually automatic:
value_and_gradient!!(rule, f, x)  # Handles CoDual construction internally
```

### **Pattern: Checking if Something is Primitive**
```julia
using Mooncake: is_primitive, DefaultCtx, ReverseMode

sig = Tuple{typeof(sin), Float64}
is_primitive(DefaultCtx, ReverseMode, sig)  # true - has hand-written rule

sig2 = Tuple{typeof(my_function), Float64}
is_primitive(DefaultCtx, ReverseMode, sig2)  # false - will derive rule
```

### **Pattern: Testing a New Rule**
```julia
using Mooncake.TestUtils: test_rule
using Random: Xoshiro

# Test your new rule:
test_rule(
    Xoshiro(123),       # RNG for reproducibility
    my_func,            # Function
    arg1, arg2;         # Arguments
    is_primitive=true,  # Expect hand-written rule
    perf_flag=:stability_and_allocs,  # Check performance
)
```

## 14. **Common Pitfalls & Solutions**

### **Pitfall 1: StackOverflowError when calling build_rrule**
**Cause**: Recursive type without custom tangent type
**Solution**: See docs/src/developer_documentation/custom_tangent_type.md
**Example**: src/rrules/tasks.jl (TaskTangent), ext/MooncakeDynamicExpressionsExt.jl (TangentNode)

### **Pitfall 2: MissingForeigncallRuleError**
**Cause**: Code calls a `ccall` without a rule
**Solution**: Write rule for Julia function that calls it, or the foreigncall itself
**Example**: src/rrules/blas.jl shows how to write foreigncall rules

### **Pitfall 3: Type instability in generated code**
**Cause**: Abstract types in primal signature, missing type assertions
**Solution**: Add type assertions in rule, or make primal type-stable
**Check**: Use JET.jl via `test_rule(...; perf_flag=:stability)`

### **Pitfall 4: Incorrect gradient for mutation**
**Cause**: Forgot to restore primal state in pullback
**Solution**: Save old values before mutation, restore in pullback
**Example**: Any `rrule!!` in src/rrules/blas.jl that saves `_copy = copy(x)`

### **Pitfall 5: Segfault or weird errors**
**Cause**: Wrong fdata/rdata types in custom rule
**Solution**: Enable debug mode, check types with `verify_fdata_value`, `verify_rdata_value`
**How**: `Config(; debug_mode=true)` or see docs/src/utilities/debug_mode.md

## 15. **Common Workflows**

> **Documentation**: docs/src/utilities/ - complete workflow guides

### **Adding a New Primitive Rule**
1. Determine signature `Tuple{typeof(f), ArgTypes...}`
2. Add `@is_primitive Context Signature` declaration
3. Implement `rrule!!(::CoDual{typeof(f)}, args::CoDual...)`
4. Implement `frule!!(::Dual{typeof(f)}, args::Dual...)` (optional)
5. Add test case to `hand_written_rule_test_cases`
6. Run `test_rule(rng, f, test_args...)`
- **Documentation**: docs/src/utilities/defining_rules.md - complete guide with examples

### **Debugging AD Issues**
1. Enable debug mode: `Config(; debug_mode=true)`
2. Use `test_rule` to isolate issue
3. Inspect IR with developer tools: `primal_ir`, `fwd_ir`, `rvs_ir`
4. Check `tangent_type`, `fdata_type`, `rdata_type` are correct
5. Verify with `test_data` for custom tangent types
- **Documentation**:
  - docs/src/utilities/debugging_and_mwes.md - debugging strategies
  - docs/src/utilities/debug_mode.md - using debug mode effectively

### **Supporting a New Type**
1. Implement `tangent_type(::Type{MyType})` if non-default
2. Implement tangent operations: `zero_tangent_internal`, `randn_tangent_internal`, etc.
3. Implement `fdata`, `rdata`, `tangent(f, r)` if custom splitting needed
4. Add `rrule!!` for `lgetfield`, `lsetfield!`, `_new_` as needed
5. Use `test_data(rng, instance)` to verify
- **Documentation**: docs/src/developer_documentation/custom_tangent_type.md
  - Step-by-step guide with complete recursive type example
  - Full checklist of required methods
  - Appendix with complete implementations

## 16. **Architecture Decisions (Why Things Are This Way)**

### **Why FData/RData Split?**
- **Problem**: Passing entire tangents around is expensive
- **Solution**: Split into mutable (fdata - passed by reference) and immutable (rdata - passed by value)
- **Benefit**: Only propagate what's necessary on each pass
- **Doc**: docs/src/understanding_mooncake/rule_system.md - "Representing Gradients"

### **Why BBCode Instead of Just IRCode?**
- **Problem**: Inserting basic blocks in IRCode is awkward and error-prone
- **Solution**: BBCode uses IDs instead of positions, making insertions safe
- **When Used**: Only reverse-mode (needs complex CFG modifications), forward-mode uses IRCode
- **Doc**: docs/src/developer_documentation/ir_representation.md - "An Alternative IR Datastructure"

### **Why LazyDerivedRule?**
- **Problem**: Recursive functions cause infinite loop during rule compilation
- **Solution**: Defer rule construction until first call
- **Example**: `f(x) = x > 0 ? f(x-1) : x` would loop forever without lazy construction
- **Doc**: docs/src/developer_documentation/misc_internals_notes.md - "How Recursion Is Handled"

### **Why Unique Tangent Types?**
- **Problem**: Multiple tangent types → type instability → 100x+ slowdowns
- **Solution**: Each primal type has exactly one tangent type
- **Benefit**: Type-stable AD code, predictable testing, clear interface
- **Doc**: docs/src/understanding_mooncake/rule_system.md - "Why Uniqueness of Type For Tangents"

### **Why Block Stack?**
- **Problem**: Need to know which block we came from on reverse pass
- **Solution**: Push block ID on forward pass, pop on reverse pass
- **Optimization**: Skip for unique predecessors (often 50%+ of blocks)
- **Location**: src/interpreter/reverse_mode.jl:81

### **Why IntrinsicsWrappers Module?**
- **Problem**: All intrinsics have type `Core.IntrinsicFunction` → can't dispatch
- **Solution**: Wrap each in a regular function with unique type
- **Benefit**: Type-stable dispatch in rules
- **Doc**: src/rrules/builtins.jl:44-84 (IntrinsicsWrappers docstring)

## 17. **Important Invariants**

> **Documentation**: docs/src/understanding_mooncake/rule_system.md - "Why Uniqueness of Type For Tangents"

1. **Uniqueness**: `tangent_type(P)` returns exactly one type for each primal type `P`
2. **Reconstruction**: `tangent(fdata(t), rdata(t)) === t` must hold
3. **Type Stability**: If primal is type-stable, AD should be type-stable
4. **State Restoration**: After pullback, all mutated state must be restored
5. **Aliasing Preservation**: Tangent structure must mirror primal aliasing
6. **No Global Mutation**: Functions must not modify global mutable state
- **Documentation**:
  - docs/src/known_limitations.md - mutation of globals, recursive types, pointers
  - docs/src/understanding_mooncake/rule_system.md - "Why Support Closures But Not Mutable Globals"

## 18. **Debugging Checklist**

When AD fails, check in this order:

1. **Does the primal run?**
   ```julia
   f(x...)  # Must work before differentiation
   ```

2. **Is there a missing primitive?**
   ```julia
   # Look for MissingForeigncallRuleError or MissingRuleForBuiltinException
   # Solution: Add rule or use @mooncake_overlay to avoid problematic code
   ```

3. **Are tangent types correct?**
   ```julia
   using Mooncake: tangent_type, fdata_type, rdata_type
   tangent_type(typeof(x))  # Should be a concrete type
   ```

4. **Enable debug mode**
   ```julia
   rule = build_rrule(f, x...; debug_mode=true)
   # Will catch fdata/rdata type mismatches
   ```

5. **Inspect generated IR**
   ```julia
   using Mooncake: fwd_ir, rvs_ir
   display(fwd_ir(Tuple{typeof(f), typeof(x)...}))
   display(rvs_ir(Tuple{typeof(f), typeof(x)...}))
   ```

6. **Check for unsupported features**
   - See docs/src/known_limitations.md
   - Global mutation, PhiCNode, UpsilonNode not supported

## 19. **Error Types**

- `MissingForeigncallRuleError` - No rule for ccall (foreigncall.jl:2-33)
- `MissingRuleForBuiltinException` - No rule for builtin (builtins.jl:14-42)
- `MissingIntrinsicWrapperException` - No intrinsic wrapper (builtins.jl:119-128)
- `UnhandledLanguageFeatureException` - Unsupported Julia feature (ir_utils.jl:273-282)
- `MooncakeRuleCompilationError` - Rule compilation failed (reverse_mode.jl:1012-1036)
- `InvalidFDataException` - Invalid forward data (fwds_rvs_data.jl:287-289)
- `InvalidRDataException` - Invalid reverse data (fwds_rvs_data.jl:750-752)
- `ValueAndGradientReturnTypeError` - Wrong return type for gradient (interface.jl:41-52)
- `ValueAndPullbackReturnTypeError` - Unsupported output (interface.jl:54-73)
- `AddToPrimalException` - Constructor issue in testing (tangents.jl:1062-1080)

## 20. **FAQs for New Contributors**

### **Q: Where do I start if I want to add support for a new package?**
A: Create an extension in `ext/` following the pattern in `ext/MooncakeNNlibExt.jl`:
1. Import necessary Mooncake utilities
2. Use `@from_rrule` for functions with ChainRules rules
3. Write custom `rrule!!` for anything else
4. Add tests in `test/ext/your_package/`

### **Q: How do I know if I need a primitive or can rely on derivation?**
A: Run `build_rrule(f, args...)` - if it fails with missing rule error, you need a primitive. If it succeeds but is slow/incorrect, consider adding a performance primitive to `DefaultCtx`.

### **Q: What's the difference between MinimalCtx and DefaultCtx?**
A:
- **MinimalCtx**: Only rules essential for correctness (e.g., builtins, foreigncalls)
- **DefaultCtx**: Includes performance rules (e.g., optimized BLAS calls)
- Always add correctness rules to MinimalCtx, performance rules to DefaultCtx

### **Q: Why does my rule work but performance is terrible?**
A: Common causes:
1. Rule isn't marked `@is_primitive` → AD re-derives it every time
2. Type instability in rule → use `@inferred` to check
3. Missing `@inline` on small functions
4. Allocations → use `@allocations` to check, may need manual optimization

### **Q: How do I test just my new rule?**
A:
```julia
using Mooncake.TestUtils: test_rule
test_rule(Xoshiro(123), my_func, test_args...; is_primitive=true)
```
Add to `hand_written_rule_test_cases` in your rrules file for CI.

### **Q: Where are Hessians computed?**
A: Apply Mooncake to itself (forward-over-reverse or reverse-over-reverse):
```julia
# Hessian = derivative of gradient
grad_func = x -> value_and_gradient!!(rule, f, x)[2][2]
hessian_rule = build_rrule(grad_func, x)
```
See test cases for examples of higher-order AD.

### **Q: What's the relationship to Enzyme.jl, Zygote.jl, etc?**
A:
- **Enzyme.jl**: Works at LLVM level (C++), handles more but harder to extend
- **Zygote.jl**: Source-to-source like Mooncake, but struggles with mutation
- **ReverseDiff.jl**: Tape-based, can give wrong answers with control flow
- **Mooncake.jl**: Source-to-source, first-class mutation support, pure Julia

## 21. **Documentation Cross-Reference**

### **Getting Started**
- **docs/src/index.md** - Project overview, goals, status, getting started
- **docs/src/tutorial.md** - DifferentiationInterface.jl and native API usage examples
- **docs/src/interface.md** - Public API reference (`Config`, `value_and_gradient!!`, etc.)

### **Understanding AD**
- **docs/src/understanding_mooncake/introduction.md** - Who docs are for, prerequisites
- **docs/src/understanding_mooncake/algorithmic_differentiation.md** - Complete mathematical foundation
  - Derivatives: scalar to Hilbert space generalization
  - Forward-mode AD explanation
  - Reverse-mode AD explanation (what and how)
  - Directional derivatives and gradients
  - Worked examples with matrices and Julia functions
- **docs/src/understanding_mooncake/rule_system.md** - Rule system specification
  - Mathematical model for Julia functions
  - Rule interface (forwards and reverse passes)
  - CoDual, fdata, rdata system
  - Testing rules
  - Why uniqueness matters

### **Practical Guides**
- **docs/src/utilities/defining_rules.md** - Complete rule-writing guide
  - Using `@mooncake_overlay` to simplify code
  - Using `@zero_adjoint` for zero-derivative functions
  - Using `@from_rrule` / `@from_chainrules` to import existing rules
  - Writing custom `rrule!!` methods
- **docs/src/utilities/debug_mode.md** - Debug mode guide
  - When to enable it
  - What it checks
  - Performance impact
- **docs/src/utilities/debugging_and_mwes.md** - Debugging and MWE creation
  - Using `test_rule` for debugging
  - Creating minimal working examples

### **Developer Internals**
- **docs/src/developer_documentation/running_tests_locally.md** - Testing workflow
  - Main testing with Revise.jl
  - Extension and integration testing
- **docs/src/developer_documentation/developer_tools.md** - IR inspection tools
  - `primal_ir`, `dual_ir`, `fwd_ir`, `rvs_ir` usage
- **docs/src/developer_documentation/tangents.md** - Tangent interface
  - `test_tangent_interface`, `test_tangent_splitting`, `test_rule_and_type_interactions`
  - Complete interface requirements
- **docs/src/developer_documentation/custom_tangent_type.md** - Custom tangent types
  - Why recursive types are challenging
  - Step-by-step guide with struct A example
  - Complete checklist of required methods
  - Full working implementation in appendix
- **docs/src/developer_documentation/ir_representation.md** - IR internals
  - Julia's SSA-form IR explained
  - Control flow, PhiNodes, basic blocks
  - IRCode vs BBCode comparison
  - Code transformation examples
- **docs/src/developer_documentation/forwards_mode_design.md** - Forward-mode design (planned)
  - Forwards-rule interface
  - Hand-written vs derived rules
  - Comparison with ForwardDiff.jl
- **docs/src/developer_documentation/reverse_mode_design.md** - Reverse-mode overview
  - Compilation process walkthrough
  - `build_rrule` flow
  - `generate_ir` explanation
- **docs/src/developer_documentation/misc_internals_notes.md** - Implementation notes
  - `tangent_type` generated function design
  - How recursion is handled via `LazyDerivedRule`

### **Limitations**
- **docs/src/known_limitations.md** - Known issues and workarounds
  - Mutation of global variables
  - Passing differentiable data as a type
  - Circular references in type declarations
  - Tangent generation and pointers

This comprehensive map provides a complete conceptual understanding of Mooncake.jl's architecture, linking every major concept to specific source locations and their corresponding documentation.
