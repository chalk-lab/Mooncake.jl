<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tapir.jl&#39;s Mathematical Interpration of Julia Functions · Tapir.jl</title><meta name="title" content="Tapir.jl&#39;s Mathematical Interpration of Julia Functions · Tapir.jl"/><meta property="og:title" content="Tapir.jl&#39;s Mathematical Interpration of Julia Functions · Tapir.jl"/><meta property="twitter:title" content="Tapir.jl&#39;s Mathematical Interpration of Julia Functions · Tapir.jl"/><meta name="description" content="Documentation for Tapir.jl."/><meta property="og:description" content="Documentation for Tapir.jl."/><meta property="twitter:description" content="Documentation for Tapir.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Tapir.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Tapir.jl</a></li><li><span class="tocitem">Understanding Tapir.jl</span><ul><li><a class="tocitem" href="../understanding_intro/">Introduction</a></li><li><a class="tocitem" href="../algorithmic_differentiation/">Algorithmic Differentiation</a></li><li class="is-active"><a class="tocitem" href>Tapir.jl&#39;s Mathematical Interpration of Julia Functions</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#A-Mathematical-Model-for-a-Computer-Programme"><span>A Mathematical Model for a Computer Programme</span></a></li><li class="toplevel"><a class="tocitem" href="#Tangents"><span>Tangents</span></a></li><li class="toplevel"><a class="tocitem" href="#The-Rule-Abstraction"><span>The Rule Abstraction</span></a></li><li class="toplevel"><a class="tocitem" href="#Asides"><span>Asides</span></a></li></ul></li><li><a class="tocitem" href="../single_block_rmad/">AD Without Control Flow</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Understanding Tapir.jl</a></li><li class="is-active"><a href>Tapir.jl&#39;s Mathematical Interpration of Julia Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tapir.jl&#39;s Mathematical Interpration of Julia Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/compintell/Tapir.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/compintell/Tapir.jl/blob/main/docs/src/mathematical_interpretation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tapir.jl&#39;s-Mathematical-Intepretation-of-Julia-Functions"><a class="docs-heading-anchor" href="#Tapir.jl&#39;s-Mathematical-Intepretation-of-Julia-Functions">Tapir.jl&#39;s Mathematical Intepretation of Julia Functions</a><a id="Tapir.jl&#39;s-Mathematical-Intepretation-of-Julia-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Tapir.jl&#39;s-Mathematical-Intepretation-of-Julia-Functions" title="Permalink"></a></h1><h1 id="A-Mathematical-Model-for-a-Computer-Programme"><a class="docs-heading-anchor" href="#A-Mathematical-Model-for-a-Computer-Programme">A Mathematical Model for a Computer Programme</a><a id="A-Mathematical-Model-for-a-Computer-Programme-1"></a><a class="docs-heading-anchor-permalink" href="#A-Mathematical-Model-for-a-Computer-Programme" title="Permalink"></a></h1><p>In order to make sense of what it might mean to differentiate a computer programme, we need some kind of differentiable mathematical model for said programme. Pearlmutter [<a href="../algorithmic_differentiation/#pearlmutter2008reverse">3</a>] introduced such a model, which we expand on here.</p><p>Think of a computer as a device which has a state, which we model as a vector in <span>$\RR^D$</span>. When a programme <code>p</code> is run, it changes this state. We model the programme <code>p</code> with a &quot;transition function&quot; <span>$t : \RR^D \to \RR^D$</span>, whose input is whatever the state is before running <code>p</code>, and whose output is whatever the state is after running <code>p</code>. If <span>$t$</span> is differentiable, then we can meaningfully define &quot;differentiating <code>p</code>&quot; to mean &quot;differentiating <span>$t$</span>&quot;. In particular, when we talk about applying reverse-mode AD to a particular Julia <code>function</code> <code>p</code>, what we mean is computing the adjoint <span>$D t [x]$</span> of the transition function <span>$t$</span> which describes <code>p</code> when the computer is in state <span>$x$</span> prior to running <code>p</code>.</p><p>Consider how we might model the Julia <code>function</code></p><pre><code class="language-julia hljs">function f(x)
    x1 = x
    x2 = f1(x1)
    x3 = f2(x1, x2)
    ...
    return fN(x1, x2, ..., xN)
end</code></pre><p>It can be thought of as a sequence of <span>$N$</span> programmes, which are run one after the other. If each <code>fn</code> is associated to transition functin <span>$t_n : \RR^D \to \RR^D$</span> then the transtion function associated to <code>f</code> is just <span>$t := t_N \circ \dots \circ t_1$</span>. We can then compute the adjoint of <span>$t$</span> in the way described in the last section:</p><p class="math-container">\[D t [x]^\ast (\bar{y}) = [ D t_1 [x_1] \circ \dots \circ D t_N [x_N] ]^\ast (\bar{y})\]</p><p><em><strong>A Simple Worked Example</strong></em></p><p>Consider applying this framework to the Julia function</p><pre><code class="language-julia hljs">f(x::Float64) = sin(cos(x))</code></pre><p>We first find the transition operator associated to the primitives <code>sin(::Float64)</code> and <code>cos(::Float64)</code>, then look at </p><p><em><strong>Advantages and Limitations</strong></em></p><p>In principle, we have now associated a precise meaning to applying reverse-mode AD to the Julia <code>function</code> <code>f</code> and shown how reverse-mode AD might be applied. This view has several advantages. It places sufficiently few restrictions on what a computer programme is allowed to do that we can imagine it being a good model for most computer programmes we shall encounter. Moreover, it gives us a precise meaning to &quot;differentiating a computer programme&quot;.</p><p>However, it has returned us to working with &quot;flat&quot; vector structures, rather than directly with the </p><h1 id="Tangents"><a class="docs-heading-anchor" href="#Tangents">Tangents</a><a id="Tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Tangents" title="Permalink"></a></h1><p>We call the argument or output of a derivative <span>$D f [x] : \mathcal{X} \to \mathcal{Y}$</span> a <em>tangent</em>, and will usually denote it with a dot over a symbol, e.g. <span>$\dot{x}$</span>. Conversely, we call an argument or output of the adjoint of this derivative <span>$D f [x]^\ast : \mathcal{Y} \to \mathcal{X}$</span> a <em>gradient</em>, and will usually denote it with a bar over a symbol, e.g. <span>$\bar{y}$</span>.</p><p>Note, however, that the sets involved are the same whether dealing with a derivative or its adjoint. Consequently, we use the same type to represent both.</p><p><em><strong>A quick aside: Non-Differentiable Data</strong></em></p><p>In the introduction to algorithmic differentiation, we assumed that the domain / range of function are the same as that of its derivative. Unfortunately, this story is only partly true. Matters are complicated by the fact that not all data types in Julia can reasonably be thought of as forming a Hilbert space. e.g. the <code>String</code> type.</p><p>Consequently we introduce the special type <code>NoTangent</code>, instances of which can be thought of as representing the set containing only a <span>$0$</span> tangent. Morally speaking, for any non-differentiable data <code>x</code>, <code>x + NoTangent() == x</code>.</p><p>Other than non-differentiable data, the model of data in Julia as living in a real-valued finite dimensional Hilbert space is quite reasonable. Therefore, we hope readers will forgive us for largely ignoring the distinction between the domain and range of a function and that of its derivative in mathematical discussions, while simultaneously drawing a distinction when discussing code.</p><p><em><strong>Representing Tangents</strong></em></p><p>The extended docstring for <a href="#Tapir.tangent_type-Tuple{Any}"><code>tangent_type</code></a> provides the best introduction to the types which are used to represent tangents.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tapir.tangent_type-Tuple{Any}" href="#Tapir.tangent_type-Tuple{Any}"><code>Tapir.tangent_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tangent_type(P)</code></pre><p>There must be a single type used to represents tangents of primals of type <code>P</code>, and it must be given by <code>tangent_type(P)</code>.</p><p><strong>Extended help</strong></p><p>The tangent types which Tapir.jl uses are quite similar in spirit to ChainRules.jl. For example, tangent &quot;vectors&quot; for</p><ol><li><code>Float64</code>s are <code>Float64</code>s,</li><li><code>Vector{Float64}</code>s are <code>Vector{Float64}</code>s, and</li><li><code>struct</code>s are other another (special) <code>struct</code> with field types specified recursively.</li></ol><p>There are, however, some major differences. Firstly, while it is certainly true that the above tangent types are permissible in ChainRules.jl, they are not the uniquely permissible types. For example, <code>ZeroTangent</code> is also a permissible type of tangent for any of them, and <code>Float32</code> is permissible for <code>Float64</code>. This is a general theme in ChainRules.jl – it intentionally declines to place restrictions on what type can be used to represent the tangent of a given type.</p><p>Tapir.jl differs from this. <strong>It insists that each primal type is associated to a <em>single</em> tangent type.</strong> Furthermore, this type is <em>always</em> given by the function <code>Tapir.tangent_type(primal_type)</code>.</p><p>Consider some more worked examples.</p><p><strong>Int</strong></p><p><code>Int</code> is not a differentiable type, so its tangent type is <code>NoTangent</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Int)
NoTangent</code></pre><p><strong>Tuples</strong></p><p>The tangent type of a <code>Tuple</code> is defined recursively based on its field types. For example</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Tuple{Float64, Vector{Float64}, Int})
Tuple{Float64, Vector{Float64}, NoTangent}</code></pre><p>There is one edge case to be aware of: if all of the field of a <code>Tuple</code> are non-differentiable, then the tangent type is <code>NoTangent</code>. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Tuple{Int, Int})
NoTangent</code></pre><p><strong>Structs</strong></p><p>As with <code>Tuple</code>s, the tangent type of a struct is, by default, given recursively. In particular, the tangent type of a <code>struct</code> type is <code>Tangent</code>. This type contains a <code>NamedTuple</code> containing the tangent to each field in the primal <code>struct</code>.</p><p>As with <code>Tuple</code>s, if all field types are non-differentiable, the tangent type of the entire struct is <code>NoTangent</code>.</p><p>There are a couple of additional subtleties to consider over <code>Tuple</code>s though. Firstly, not all fields of a <code>struct</code> have to be defined. Fortunately, Julia makes it easy to determine how many of the fields might possibly not be defined. The tangent associated to any field which might possibly not be defined is wrapped in a <code>PossiblyUninitTangent</code>.</p><p>Furthermore, <code>struct</code>s can have fields whose static type is abstract. For example</p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x
       end</code></pre><p>If you ask for the tangent type of <code>Foo</code>, you will see that it is</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Foo)
Tangent{@NamedTuple{x}}</code></pre><p>Observe that the field type associated to <code>x</code> is <code>Any</code>. The way to understand this result is to observe that</p><ol><li><code>x</code> could have literally any type at runtime, so we know nothing about what its tangent  type must be until runtime, and</li><li>we require that the tangent type of <code>Foo</code> be unique.</li></ol><p>The consequence of these two considerations is that the tangent type of <code>Foo</code> must be able to contain any type of tangent in its <code>x</code> field. It follows that the fieldtype of the <code>x</code> field of <code>Foo</code>s tangent must be <code>Any</code>.</p><p><strong>Mutable Structs</strong></p><p>The tangent type for <code>mutable struct</code>s have the same set of considerations as <code>struct</code>s. The only difference is that they must themselves be mutable. Consequently, we use a type called <code>MutableTangent</code> to represent their tangents. It is a <code>mutable struct</code> with the same structure as <code>Tangent</code>.</p><p>For example, if you ask for the <code>tangent_type</code> of</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Bar
           x::Float64
       end</code></pre><p>you will find that it is</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Bar)
MutableTangent{@NamedTuple{x::Float64}}</code></pre><p><strong>Primitive Types</strong></p><p>We&#39;ve already seen a couple of primitive types (<code>Float64</code> and <code>Int</code>). The basic story here is that all primitive types require an explicit specification of what their tangent type must be.</p><p>One interesting case are <code>Ptr</code> types. The tangent type of a <code>Ptr{P}</code> is <code>Ptr{T}</code>, where <code>T = tangent_type(P)</code>. For example</p><pre><code class="language-julia hljs">julia&gt; tangent_type(Ptr{Float64})
Ptr{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Tapir.jl/blob/6557ca8ae4867e3e71a74c87c3e659df93157ba4/src/tangents.jl#L148-L267">source</a></section></article><p><em><strong>FData and RData</strong></em></p><p>While tangents are the things used to represent gradients, they are not strictly what gets propagated forwards and backwards by rules during AD. Rather, they are split into fdata and rdata, and these are passed around.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Tapir.fdata_type-Tuple{Any}" href="#Tapir.fdata_type-Tuple{Any}"><code>Tapir.fdata_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fdata_type(T)</code></pre><p>Returns the type of the forwards data associated to a tangent of type <code>T</code>.</p><p><strong>Extended help</strong></p><p>Rules in Tapir.jl do not operate on tangents directly. Rather, functionality is defined to split each tangent into two components, that we call <em>fdata</em> (forwards-pass data) and <em>rdata</em> (reverse-pass data). In short, any component of a tangent which is identified by its address (e.g. a <code>mutable struct</code>s or an <code>Array</code>) gets passed around on the forwards-pass of AD and is incremented in-place on the reverse-pass, while components of tangents identified by their value get propagated and accumulated only on the reverse-pass.</p><p>Given a tangent type <code>T</code>, you can find out what type its fdata and rdata must be with <code>fdata_type(T)</code> and <code>rdata_type(T)</code> respectively. A consequence of this is that there is exactly one valid fdata type and rdata type for each primal type.</p><p>Given a tangent <code>t</code>, you can get its fdata and rdata using <code>f = fdata(t)</code> and <code>r = rdata(t)</code> respectively. f can be re-combined to recover the original tangent using the binary version of <code>tangent</code>: <code>tangent(f, r)</code>. It must always hold that</p><pre><code class="language-julia hljs">tangent(fdata(t), rdata(t)) === t</code></pre><p>The need for all of this is explained in the docs, but for now it suffices to consider our running examples again, and to see what their fdata and rdata look like.</p><p><strong>Int</strong></p><p><code>Int</code>s are non-differentiable types, so there is nothing to pass around on the forwards- or reverse-pass. Therefore</p><pre><code class="language-julia-repl hljs">julia&gt; fdata_type(tangent_type(Int)), rdata_type(tangent_type(Int))
(NoFData, NoRData)</code></pre><p><strong>Float64</strong></p><p>The tangent type of <code>Float64</code> is <code>Float64</code>. <code>Float64</code>s are identified by their value / have no fixed address, so</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(Float64), rdata_type(Float64))
(NoFData, Float64)</code></pre><p><strong>Vector{Float64}</strong></p><p>The tangent type of <code>Vector{Float64}</code> is <code>Vector{Float64}</code>. A <code>Vector{Float64}</code> is identified by its address, so</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(Vector{Float64}), rdata_type(Vector{Float64}))
(Vector{Float64}, NoRData)</code></pre><p><strong>Tuple{Float64, Vector{Float64}, Int}</strong></p><p>This is an example of a type which has both fdata and rdata. The tangent type for <code>Tuple{Float64, Vector{Float64}, Int}</code> is <code>Tuple{Float64, Vector{Float64}, NoTangent}</code>. <code>Tuple</code>s have no fixed memory address, so we interogate each field on its own. We have already established the fdata and rdata types for each element, so we recurse to obtain:</p><pre><code class="language-julia-repl hljs">julia&gt; T = tangent_type(Tuple{Float64, Vector{Float64}, Int})
Tuple{Float64, Vector{Float64}, NoTangent}

julia&gt; (fdata_type(T), rdata_type(T))
(Tuple{NoFData, Vector{Float64}, NoFData}, Tuple{Float64, NoRData, NoRData})</code></pre><p>The zero tangent for <code>(5.0, [5.0])</code> is <code>t = (0.0, [0.0])</code>. <code>fdata(t)</code> returns <code>(NoFData(), [0.0])</code>, where the second element is <code>===</code> to the second element of <code>t</code>. <code>rdata(t)</code> returns <code>(0.0, NoRData())</code>. In this example, <code>t</code> contains a mixture of data, some of which is identified by its value, and some of which is identified by its address, so there is some fdata and some rdata.</p><p><strong>Structs</strong></p><p>Structs are handled in more-or-less the same way as <code>Tuple</code>s, albeit with the possibility of undefined fields needing to be explicitly handled. For example, a struct such as</p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x::Float64
           y
           z::Int
       end</code></pre><p>has tangent type</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Foo)
Tangent{@NamedTuple{x::Float64, y, z::NoTangent}}</code></pre><p>Its fdata and rdata are given by special <code>FData</code> and <code>RData</code> types:</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(tangent_type(Foo)), rdata_type(tangent_type(Foo)))
(Tapir.FData{@NamedTuple{x::NoFData, y, z::NoFData}}, Tapir.RData{@NamedTuple{x::Float64, y, z::NoRData}})</code></pre><p>Practically speaking, <code>FData</code> and <code>RData</code> both have the same structure as <code>Tangent</code>s and are just used in different contexts.</p><p><strong>Mutable Structs</strong></p><p>The fdata for a <code>mutable struct</code>s is its tangent, and it has no rdata. This is because <code>mutable struct</code>s have fixed memory addresses, and can therefore be incremented in-place. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Bar
           x::Float64
           y
           z::Int
       end</code></pre><p>has tangent type</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Bar)
MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}</code></pre><p>and fdata / rdata types</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(tangent_type(Bar)), rdata_type(tangent_type(Bar)))
(MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}, NoRData)</code></pre><p><strong>Primitive Types</strong></p><p>As with tangents, each primitive type must specify what its fdata and rdata is. See specific examples for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Tapir.jl/blob/6557ca8ae4867e3e71a74c87c3e659df93157ba4/src/fwds_rvs_data.jl#L27-L147">source</a></section></article><h1 id="The-Rule-Abstraction"><a class="docs-heading-anchor" href="#The-Rule-Abstraction">The Rule Abstraction</a><a id="The-Rule-Abstraction-1"></a><a class="docs-heading-anchor-permalink" href="#The-Rule-Abstraction" title="Permalink"></a></h1><p>A rule must return a <code>CoDual</code> and a function to run the reverse-pass, known as the pullback. Upon exit from the rule, it must be true that</p><ol><li>the state of the arguments / output are the same as they would be had the primal been run, and</li><li>the uniqueness of the mapping between address-identified primals and their fdata is maintained.</li></ol><p>Upon exit from the pullback, it must be true that</p><ol><li>the primal state is as it was before running the rule,</li><li>the fdata for the arguments has been incremented by the fdata in <span>$D f[x]^\ast (\bar{y})$</span>, and </li><li>the rdata for the arguments is equal to the rdata in <span>$D f[x]^\ast (\bar{y})$</span>.</li></ol><p>Tapir.jl makes use of a rule system which is at first glance similar to the <code>rrule</code> function offered by ChainRules.jl. However, owing to Tapir.jl&#39;s support for mutation (e.g. differentiating through functions which write to arrays) and high degree of precision around the types used to represent (co)-tangent-like data, the number of situations in which the two are identical are actually rather small.</p><p>Nevertheless, we begin this explanation with an example which should be familiar to anyone who has used ChainRules.jl and seen its rrule. Once this example has been explained, we move into new territory.</p><h3 id="Functions-of-Scalars:-from-ChainRules.rrule-to-Tapir.rrule!!"><a class="docs-heading-anchor" href="#Functions-of-Scalars:-from-ChainRules.rrule-to-Tapir.rrule!!">Functions of Scalars: from ChainRules.rrule to Tapir.rrule!!</a><a id="Functions-of-Scalars:-from-ChainRules.rrule-to-Tapir.rrule!!-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-of-Scalars:-from-ChainRules.rrule-to-Tapir.rrule!!" title="Permalink"></a></h3><p>Consider the simple Julia function</p><pre><code class="language-julia hljs">mul(a::Float64, b::Float64) = a * b</code></pre><p>A <code>ChainRules.rrule</code> for this might look something like</p><pre><code class="language-julia hljs">function ChainRules.rrule(::typeof(mul), a::Float64, b::Float64)
    mul_pullback(dc::Float64) = NoTangent(), dc * b, dc * a
    return a * b, mul_pullback
end</code></pre><p>The corresponding <code>Tapir.rrule!!</code> would be something like</p><pre><code class="language-julia hljs">function Tapir.rrule!!(::CoDual{typeof(mul)}, a::CoDual{Float64}, b::CoDual{Float64})
    _a = primal(a)
    _b = primal(b)
    mul_pullback!!(dc::Float64) = NoRData(), dc * _b, dc * _a
    return CoDual(_a * _b, NoFData()), mul_pullback!
end</code></pre><p>The core differences between the <code>rrule</code> and <code>rrule!!</code> are:</p><ol><li>each argument is a <code>CoDual</code>, which contains the primal and one other piece of data (more on this later),</li><li>we must extract the primal values from <code>a</code> and <code>b</code> using the <code>primal</code> function in order to access them,</li><li><code>NoTangent()</code> is replaced by <code>NoRData()</code>, and</li><li>we must return another <code>CoDual</code>, rather than just the primal value (more on this later).</li></ol><p>The point of this example is to highlight that <code>Tapir.rrule!!</code>s look a lot like <code>ChainRules.rrule</code>s in some situations, so some of your existing knowledge should transfer over.</p><h3 id="Functions-of-Vectors"><a class="docs-heading-anchor" href="#Functions-of-Vectors">Functions of Vectors</a><a id="Functions-of-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-of-Vectors" title="Permalink"></a></h3><p>We now turn to the obvious question: why do <code>Tapir.rrule!!</code>s differ from <code>ChainRules.rrule</code>s? The short answer is that Tapir.jl requires that each unique primal memory address associated to differentiable data be associated to a unique tangent (a.k.a. shadow) memory address. (See <a href="#Why-Unique-Memory-Address">Why Unique Memory Address</a> to understand why this is necessary.)</p><p>To see how this is achieved, consider the function</p><pre><code class="language-julia hljs">function set_1!(x::Vector{Float64}, y::Float64)
    x[1] = y
    return x
end</code></pre><p>A valid <code>Tapir.rrule!!</code> for this function given below. There are a lot of concepts introduced here, so you&#39;ll need to hop back and forth between this and the text below which explains everything.</p><pre><code class="language-julia hljs">function Tapir.rrule!!(
    ::CoDual{typeof(set_1!)}, x::CoDual{Vector{Float64}}, y::CoDual{Float64}
)
    # Extract the primal and &quot;fdata&quot; from x.
    px = primal(x)
    dx = tangent(x)

    # Store the current values.
    px_1_old = px[1]
    dx_1_old = dx[1]

    # Set x_p[1] to `y` and zero-out x_f[1].
    px[1] = primal(y)
    dx[1] = 0.0

    function set_1_pullback!!(::NoRData)

        # The (co)tangent to `y` is just the value in the first position of x_f.
        dy = dx

        # We _must_ undo any changes which occur on the forwards-pass, both to the primal
        # and the fdata (the forwards-component of the tangent).
        px[1] = px_1_old
        dx[1] = dx_1_old

        # There&#39;s nothing to propagate backwards for `f` because it&#39;s non-differentiable.
        # It has &quot;no reverse data&quot;, hence `NoRData`.
        df = NoRData()

        # There&#39;s nothing to propagate backwards for `x`, because its tangent is entirely
        # represented by `dx` on the forwards-pass, hence `NoRData`.
        dx = NoRData()

        return df, dx, dy
    end

    # Just return x (the CoDual) -- this propagates forwards the correct unique tangent
    # memory for `x`.
    return x, set_1_pullback!!
end</code></pre><p>Let&#39;s unpack the above:</p><h4 id="Memory-Propagation"><a class="docs-heading-anchor" href="#Memory-Propagation">Memory Propagation</a><a id="Memory-Propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Memory-Propagation" title="Permalink"></a></h4><p>We stated at the top of this section that each unique address associated to differentiable data must have a unique tangent memory address associated to it. To see how this rule preserves this, consider the function</p><pre><code class="language-julia hljs">g(x::Vector{Float64}, y::Float64) = x, set_1!(x, y)</code></pre><p>The output of <code>g</code> is a <code>Tuple</code> with the same <code>Vector{Float64}</code> in each element. Therefore, during AD, they <em>must</em> be associated to the same tangent address. Happily, simple by by returning <code>x</code> at the end of the <code>rrule!!</code> for <code>set_1!</code> we ensure that this happens.</p><h4 id="The-other-field-in-a-CoDual"><a class="docs-heading-anchor" href="#The-other-field-in-a-CoDual">The other field in a <code>CoDual</code></a><a id="The-other-field-in-a-CoDual-1"></a><a class="docs-heading-anchor-permalink" href="#The-other-field-in-a-CoDual" title="Permalink"></a></h4><p>In this example, the other field in the <code>CoDual</code> associated to <code>x</code> must contain a <code>Vector{Float64}</code>, which represents the tangent to <code>x</code>. We call this the <em>fdata</em> (&quot;forwards data&quot;) associated to <code>x</code>. We didn&#39;t show it, but the fdata associated to <code>y</code> is <code>NoFData</code> (&quot;no forwards data&quot;), indicating that there is no additional data associated to <code>y</code> on the forwards-pass.</p><p>Why is this the case?</p><h4 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h4><p>Note that this very simple function does <em>not</em> have a meaningful <code>ChainRules.rrule</code> counterpart because it mutates (modifies) <code>x</code>, and <code>ChainRules.rrule</code> does not support mutation.</p><h1 id="Asides"><a class="docs-heading-anchor" href="#Asides">Asides</a><a id="Asides-1"></a><a class="docs-heading-anchor-permalink" href="#Asides" title="Permalink"></a></h1><h3 id="Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?"><a class="docs-heading-anchor" href="#Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?">Why Uniqueness of Type For Tangents / FData / RData?</a><a id="Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Uniqueness-of-Type-For-Tangents-/-FData-/-RData?" title="Permalink"></a></h3><p>Why does Tapir.jl insist that each primal type <code>P</code> be paired with a single tangent type <code>T</code>, as opposed to being more permissive. There are a few notable reasons:</p><ol><li>To provide a precise interface. Rules pass fdata around on the forwards-pass and rdata on the reverse-pass – being able to make strong assumptions about the type of the fdata / rdata given the primal type makes implementing rules much easier in practice.</li><li>Conditional type stability. We wish to have a high degree of confidence that if the primal code is type-stable, then the AD code will also be. It is straightforward to construct type stable primal codes which have type-unstable forwards- and reverse-passes if you permit there to be more than one fdata / rdata type for a given primal. So while uniqueness is certainly not sufficient on its own to guarantee conditional type stability, it is probably necessary in general.</li><li>Test-case generation and coverage. There being a unique tangent / fdata / rdata type for each primal makes being confident that a given rule is being tested thoroughly much easier. For a given primal, rather than there being many possible input / output types to consider, there is just one.</li></ol><p>This topic, in particular what goes wrong with permissive tangent type systems like those employed by ChainRules, deserves a more thorough treatment – hopefully someone will write something more expansive on this topic at some point.</p><h3 id="Why-Unique-Memory-Address"><a class="docs-heading-anchor" href="#Why-Unique-Memory-Address">Why Unique Memory Address</a><a id="Why-Unique-Memory-Address-1"></a><a class="docs-heading-anchor-permalink" href="#Why-Unique-Memory-Address" title="Permalink"></a></h3></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../algorithmic_differentiation/">« Algorithmic Differentiation</a><a class="docs-footer-nextpage" href="../single_block_rmad/">AD Without Control Flow »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Monday 24 June 2024 13:54">Monday 24 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
