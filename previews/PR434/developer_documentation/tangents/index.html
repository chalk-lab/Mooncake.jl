<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tangents · Mooncake.jl</title><meta name="title" content="Tangents · Mooncake.jl"/><meta property="og:title" content="Tangents · Mooncake.jl"/><meta property="twitter:title" content="Tangents · Mooncake.jl"/><meta name="description" content="Documentation for Mooncake.jl."/><meta property="og:description" content="Documentation for Mooncake.jl."/><meta property="twitter:description" content="Documentation for Mooncake.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Mooncake.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Mooncake.jl</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><a class="tocitem" href="../../interface/">Interface</a></li><li><span class="tocitem">Understanding Mooncake.jl</span><ul><li><a class="tocitem" href="../../understanding_mooncake/introduction/">Introduction</a></li><li><a class="tocitem" href="../../understanding_mooncake/algorithmic_differentiation/">Algorithmic Differentiation</a></li><li><a class="tocitem" href="../../understanding_mooncake/rule_system/">Mooncake.jl&#39;s Rule System</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../../utilities/defining_rules/">Defining Rules</a></li><li><a class="tocitem" href="../../utilities/debug_mode/">Debug Mode</a></li><li><a class="tocitem" href="../../utilities/debugging_and_mwes/">Debugging and MWEs</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../running_tests_locally/">Running Tests Locally</a></li><li><a class="tocitem" href="../developer_tools/">Developer Tools</a></li><li class="is-active"><a class="tocitem" href>Tangents</a><ul class="internal"><li><a class="tocitem" href="#Testing-Functionality"><span>Testing Functionality</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li></ul></li><li><a class="tocitem" href="../forwards_mode_design/">Forwards-Mode Design</a></li><li><a class="tocitem" href="../misc_internals_notes/">Misc. Internals Notes</a></li><li><a class="tocitem" href="../internal_docstrings/">Internal Docstrings</a></li></ul></li><li><a class="tocitem" href="../../known_limitations/">Known Limitations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Documentation</a></li><li class="is-active"><a href>Tangents</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tangents</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/compintell/Mooncake.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/compintell/Mooncake.jl/blob/main/docs/src/developer_documentation/tangents.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tangents"><a class="docs-heading-anchor" href="#Tangents">Tangents</a><a id="Tangents-1"></a><a class="docs-heading-anchor-permalink" href="#Tangents" title="Permalink"></a></h1><p>As discussed in <a href="../../understanding_mooncake/rule_system/#Representing-Gradients">Representing Gradients</a>, Mooncake requires that each &quot;primal&quot; type be associated to a unique &quot;tangent&quot; type, given by the function <a href="../misc_internals_notes/#tangent_type">tangent_type</a>. Moreover, we must be able to &quot;split&quot; a given tangent into its <em>fdata</em> (&quot;forwards-data&quot;) and <em>rdata</em> (&quot;reverse-data&quot;), whose types are given by <a href="#Mooncake.fdata_type"><code>Mooncake.fdata_type</code></a> and <a href="#Mooncake.rdata_type"><code>Mooncake.rdata_type</code></a> respectively.</p><p>Very occassionally it may be necessary to specify your own tangent type. This is not an entirely trivial undertaking, as there is quite a lot of functionality that must be added to make it work properly. So, before diving in to add your own custom type, seriously consider whether it is worth the effort, and whether the default definition given by Mooncake are really inadequate for your use-case.</p><h2 id="Testing-Functionality"><a class="docs-heading-anchor" href="#Testing-Functionality">Testing Functionality</a><a id="Testing-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Functionality" title="Permalink"></a></h2><p>The interface is given in the form of three functions:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.TestUtils.test_tangent_interface" href="#Mooncake.TestUtils.test_tangent_interface"><code>Mooncake.TestUtils.test_tangent_interface</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_tangent_interface(rng::AbstractRNG, p; interface_only=false)</code></pre><p>Verify that standard functionality for tangents runs, and is consistent. This function is the defacto formal definition of the &quot;tangent interface&quot; – if this function runs without error for a given value of <code>p</code>, then that <code>p</code> satisfies the tangent interface.</p><p><strong>Extended Help</strong></p><p>Verifies that the following functions are implemented correctly (as far as possible) for <code>p</code> / its type, and its tangents / their type:</p><ul><li><a href="../misc_internals_notes/#tangent_type"><code>tangent_type</code></a></li><li><a href="#Mooncake.zero_tangent"><code>zero_tangent</code></a></li><li><a href="#Mooncake.randn_tangent"><code>randn_tangent</code></a></li><li><a href="#Mooncake.TestUtils.has_equal_data"><code>TestUtils.has_equal_data</code></a></li><li><a href="#Mooncake.increment!!"><code>increment!!</code></a></li><li><a href="#Mooncake.set_to_zero!!"><code>set_to_zero!!</code></a></li><li><a href="#Mooncake._add_to_primal"><code>_add_to_primal</code></a></li><li><a href="#Mooncake._diff"><code>_diff</code></a></li><li><a href="#Mooncake._dot"><code>_dot</code></a></li><li><a href="#Mooncake._scale"><code>_scale</code></a></li><li><a href="#Mooncake.TestUtils.populate_address_map"><code>TestUtils.populate_address_map</code></a></li></ul><p>In conjunction with the functions tested by <a href="#Mooncake.TestUtils.test_tangent_splitting"><code>test_tangent_splitting</code></a>, these functions constitute a complete set of functions which must be applicable to <code>p</code> in order to ensure that it operates correctly in the context of reverse-mode AD. This list should be up to date at any given point in time, but the best way to verify that you&#39;ve implemented everything is simply to run this function, and see whether it errors / produces a failing test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/test_utils.jl#L801-L829">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.TestUtils.test_tangent_splitting" href="#Mooncake.TestUtils.test_tangent_splitting"><code>Mooncake.TestUtils.test_tangent_splitting</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_tangent_splitting(rng::AbstractRNG, p::P) where {P}</code></pre><p>Verify that tangent splitting functionality associated to primal <code>p</code> works correctly. Ensure that <a href="#Mooncake.TestUtils.test_tangent_interface"><code>test_tangent_interface</code></a> runs for <code>p</code> before running these tests.</p><p><strong>Extended Help</strong></p><p>Verifies that the following functionality work correctly for <code>p</code> / its type / tangents:</p><ul><li><a href="#Mooncake.fdata_type"><code>Mooncake.fdata_type</code></a></li><li><a href="#Mooncake.rdata_type"><code>Mooncake.rdata_type</code></a></li><li><a href="#Mooncake.fdata"><code>Mooncake.fdata</code></a></li><li><a href="#Mooncake.rdata"><code>Mooncake.rdata</code></a></li><li><a href="#Mooncake.uninit_fdata"><code>Mooncake.uninit_fdata</code></a></li><li><a href="#Mooncake.tangent_type"><code>Mooncake.tangent_type</code></a> (binary method)</li><li><a href="../internal_docstrings/#Mooncake.tangent-Tuple{Mooncake.NoFData, Mooncake.NoRData}"><code>Mooncake.tangent</code></a> (binary method)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/test_utils.jl#L1122-L1138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.TestUtils.test_rule_and_type_interactions" href="#Mooncake.TestUtils.test_rule_and_type_interactions"><code>Mooncake.TestUtils.test_rule_and_type_interactions</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_rule_and_type_interactions(rng::AbstractRNG, p)</code></pre><p>Check that a collection of standard functions for which we <em>ought</em> to have a working rrule for <code>p</code> work, and produce the correct answer. For example, the <code>rrule!!</code> for <code>typeof</code> should work correctly on any type, we should have a working rule for <code>getfield</code> for any struct-type, and we should have a rule for <code>setfield!</code> for any mutable struct type. See extended help for more info.</p><p><strong>Extended Help</strong></p><p>The purpose of this test is to ensure that, for any given <code>p</code>, the full range of primitive functions that <em>ought</em> to work on it, do indeed work on it.</p><p>This is one part of the interface where some care <em>might</em> be required. If, for some reason, it should <em>never</em> be the case that e.g. for a particular <code>p</code>, <code>getfield</code> should be called, then it may make no sense at all to run these tests. In such cases, the author of the type is responsible for knowing what they are doing. Please open an issue to discuss for your type if you are at all unsure what to do.</p><p>When defining a custom tangent type for <code>P</code>, the functions that you will need to pay attention to writing rules for are</p><ul><li><a href="../internal_docstrings/#Mooncake._new_-Union{Tuple{N}, Tuple{T}, Tuple{Type{T}, Vararg{Any, N}}} where {T, N}"><code>Mooncake._new_</code></a></li><li><a href="../internal_docstrings/#Mooncake.lgetfield-Union{Tuple{f}, Tuple{Any, Val{f}}} where f"><code>Mooncake.lgetfield</code></a></li><li><a href="../internal_docstrings/#Mooncake.lsetfield!-Union{Tuple{name}, Tuple{Any, Val{name}, Any}} where name"><code>Mooncake.lsetfield!</code></a></li></ul><p>In all cases, you may wish to consult the current implementations of <code>rrule!!</code> for these functions for inspiration regarding how you might implement them for your type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/test_utils.jl#L1217-L1245">source</a></section></article><p>You can call all three of these functions at once using</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.TestUtils.test_data" href="#Mooncake.TestUtils.test_data"><code>Mooncake.TestUtils.test_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">test_data(rng::AbstractRNG, p::P)</code></pre><p>Verify that all tangent / fdata / rdata functionality work properly for <code>x</code>. Furthermore, verify that all primitives listed in <code>TestUtils.test_rule_and_type_interactions</code> work correctly on <code>x</code>. This functionality is particularly useful if you are writing your own custom tangent / fdata / rdata types and want to be confident that you have implemented the functionality that you need in order to make these custom types work with all the rules written in Mooncake itself.</p><p>You should consult the docstrings for <a href="#Mooncake.TestUtils.test_tangent_interface"><code>test_tangent_interface</code></a>, <a href="#Mooncake.TestUtils.test_tangent_splitting"><code>test_tangent_splitting</code></a>, and <a href="#Mooncake.TestUtils.test_rule_and_type_interactions"><code>test_rule_and_type_interactions</code></a>, in order to see what is required to satisfy the full tangent interface for <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/test_utils.jl#L1351-L1364">source</a></section></article><p>If all the tests in these functions pass, then you have satisfied the interface.</p><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><p>Below are the docstrings for each function tested by <a href="#Mooncake.TestUtils.test_tangent_interface"><code>Mooncake.TestUtils.test_tangent_interface</code></a> and <a href="#Mooncake.TestUtils.test_tangent_splitting"><code>Mooncake.TestUtils.test_tangent_splitting</code></a>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.tangent_type" href="#Mooncake.tangent_type"><code>Mooncake.tangent_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tangent_type(P)</code></pre><p>There must be a single type used to represents tangents of primals of type <code>P</code>, and it must be given by <code>tangent_type(P)</code>.</p><p>Warning: this function assumes the effects <code>:removable</code> and <code>:consistent</code>. This is necessary to ensure good performance, but imposes precise constraints on your implementation. If adding new methods to <code>tangent_type</code>, you should consult the extended help of <code>Base.@assume_effects</code> to see what this imposes upon your implementation.</p><p><strong>Extended help</strong></p><p>The tangent types which Mooncake.jl uses are quite similar in spirit to ChainRules.jl. For example, tangent &quot;vectors&quot; for</p><ol><li><code>Float64</code>s are <code>Float64</code>s,</li><li><code>Vector{Float64}</code>s are <code>Vector{Float64}</code>s, and</li><li><code>struct</code>s are other another (special) <code>struct</code> with field types specified recursively.</li></ol><p>There are, however, some major differences. Firstly, while it is certainly true that the above tangent types are permissible in ChainRules.jl, they are not the uniquely permissible types. For example, <code>ZeroTangent</code> is also a permissible type of tangent for any of them, and <code>Float32</code> is permissible for <code>Float64</code>. This is a general theme in ChainRules.jl – it intentionally declines to place restrictions on what type can be used to represent the tangent of a given type.</p><p>Mooncake.jl differs from this. <strong>It insists that each primal type is associated to a <em>single</em> tangent type.</strong> Furthermore, this type is <em>always</em> given by the function <code>Mooncake.tangent_type(primal_type)</code>.</p><p>Consider some more worked examples.</p><p><strong>Int</strong></p><p><code>Int</code> is not a differentiable type, so its tangent type is <code>NoTangent</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Int)
NoTangent</code></pre><p><strong>Tuples</strong></p><p>The tangent type of a <code>Tuple</code> is defined recursively based on its field types. For example</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Tuple{Float64, Vector{Float64}, Int})
Tuple{Float64, Vector{Float64}, NoTangent}</code></pre><p>There is one edge case to be aware of: if all of the field of a <code>Tuple</code> are non-differentiable, then the tangent type is <code>NoTangent</code>. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Tuple{Int, Int})
NoTangent</code></pre><p><strong>Structs</strong></p><p>As with <code>Tuple</code>s, the tangent type of a struct is, by default, given recursively. In particular, the tangent type of a <code>struct</code> type is <code>Tangent</code>. This type contains a <code>NamedTuple</code> containing the tangent to each field in the primal <code>struct</code>.</p><p>As with <code>Tuple</code>s, if all field types are non-differentiable, the tangent type of the entire struct is <code>NoTangent</code>.</p><p>There are a couple of additional subtleties to consider over <code>Tuple</code>s though. Firstly, not all fields of a <code>struct</code> have to be defined. Fortunately, Julia makes it easy to determine how many of the fields might possibly not be defined. The tangent associated to any field which might possibly not be defined is wrapped in a <code>PossiblyUninitTangent</code>.</p><p>Furthermore, <code>struct</code>s can have fields whose static type is abstract. For example</p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x
       end</code></pre><p>If you ask for the tangent type of <code>Foo</code>, you will see that it is</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Foo)
Tangent{@NamedTuple{x}}</code></pre><p>Observe that the field type associated to <code>x</code> is <code>Any</code>. The way to understand this result is to observe that</p><ol><li><code>x</code> could have literally any type at runtime, so we know nothing about what its tangent  type must be until runtime, and</li><li>we require that the tangent type of <code>Foo</code> be unique.</li></ol><p>The consequence of these two considerations is that the tangent type of <code>Foo</code> must be able to contain any type of tangent in its <code>x</code> field. It follows that the fieldtype of the <code>x</code> field of <code>Foo</code>s tangent must be <code>Any</code>.</p><p><strong>Mutable Structs</strong></p><p>The tangent type for <code>mutable struct</code>s have the same set of considerations as <code>struct</code>s. The only difference is that they must themselves be mutable. Consequently, we use a type called <code>MutableTangent</code> to represent their tangents. It is a <code>mutable struct</code> with the same structure as <code>Tangent</code>.</p><p>For example, if you ask for the <code>tangent_type</code> of</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Bar
           x::Float64
       end</code></pre><p>you will find that it is</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Bar)
MutableTangent{@NamedTuple{x::Float64}}</code></pre><p><strong>Primitive Types</strong></p><p>We&#39;ve already seen a couple of primitive types (<code>Float64</code> and <code>Int</code>). The basic story here is that all primitive types require an explicit specification of what their tangent type must be.</p><p>One interesting case are <code>Ptr</code> types. The tangent type of a <code>Ptr{P}</code> is <code>Ptr{T}</code>, where <code>T = tangent_type(P)</code>. For example</p><pre><code class="language-julia hljs">julia&gt; tangent_type(Ptr{Float64})
Ptr{Float64}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L149-L273">source</a></section><section><div><pre><code class="language-julia hljs">tangent_type(F::Type, R::Type)::Type</code></pre><p>Given the type of the fdata and rdata, <code>F</code> and <code>R</code> resp., for some primal type, compute its tangent type. This method must be equivalent to <code>tangent_type(_typeof(primal))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/fwds_rvs_data.jl#L849-L854">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.zero_tangent" href="#Mooncake.zero_tangent"><code>Mooncake.zero_tangent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_tangent(x)</code></pre><p>Returns the unique zero element of the tangent space of <code>x</code>. It is an error for the zero element of the tangent space of <code>x</code> to be represented by anything other than that which this function returns.</p><p>Internally, <code>zero_tangent</code> calls <code>zero_tangent_internal</code>, which handles different types of inputs differently. <code>zero_tangent_internal</code> has two variants:</p><ol><li>For <code>isbitstype</code> types, <code>zero_tangent_internal</code> takes one argument. </li><li>Otherwise, <code>zero_tangent_internal</code> takes another argument which is an <code>IdDict</code>, which</li></ol><p>handles both circular references and aliasing correctly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L453-L465">source</a></section><section><div><pre><code class="language-julia hljs">zero_tangent(primal, fdata)</code></pre><p>Equivalent to <code>tangent(fdata, rdata(zero_tangent(primal)))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/fwds_rvs_data.jl#L975-L979">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.randn_tangent" href="#Mooncake.randn_tangent"><code>Mooncake.randn_tangent</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">randn_tangent(rng::AbstractRNG, x::T) where {T}</code></pre><p>Required for testing. Generate a randomly-chosen tangent to <code>x</code>. The design is closely modelled after <code>zero_tangent</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L555-L561">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.TestUtils.has_equal_data" href="#Mooncake.TestUtils.has_equal_data"><code>Mooncake.TestUtils.has_equal_data</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_equal_data(x, y; equal_undefs=true)</code></pre><p>Determine if two objects <code>x</code> and <code>y</code> have equivalent data. If <code>equal_undefs</code>  is <code>true</code>, undefined elements in arrays or unassigned fields in structs are  considered equal.</p><p>The main logic is implemented in <code>has_equal_data_internal</code>, which is a recursive function that takes an additional <code>visited</code> dictionary to track visited objects and avoid infinite recursion in cases of circular references.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/test_utils.jl#L172-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.increment!!" href="#Mooncake.increment!!"><code>Mooncake.increment!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increment!!(x::T, y::T) where {T}</code></pre><p>Add <code>x</code> to <code>y</code>. If <code>ismutabletype(T)</code>, then <code>increment!!(x, y) === x</code> must hold. That is, <code>increment!!</code> will mutate <code>x</code>. This must apply recursively if <code>T</code> is a composite type whose fields are mutable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L634-L640">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.set_to_zero!!" href="#Mooncake.set_to_zero!!"><code>Mooncake.set_to_zero!!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_to_zero!!(x)</code></pre><p>Set <code>x</code> to its zero element (<code>x</code> should be a tangent, so the zero must exist).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L674-L678">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake._add_to_primal" href="#Mooncake._add_to_primal"><code>Mooncake._add_to_primal</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_add_to_primal(p::P, t::T, unsafe::Bool=false) where {P, T}</code></pre><p>Adds <code>t</code> to <code>p</code>, returning a <code>P</code>. It must be the case that <code>tangent_type(P) == T</code>.</p><p>If <code>unsafe</code> is <code>true</code> and <code>P</code> is a composite type, then <code>_add_to_primal</code> will construct a new instance of <code>P</code> by directly invoking the <code>:new</code> instruction for <code>P</code>, rather than attempting to use the default constructor for <code>P</code>. This is fine if you are confident that the new <code>P</code> constructed by adding <code>t</code> to <code>p</code> will always be a valid instance of <code>P</code>, but could cause problems if you are not confident of this.</p><p>This is, for example, fine for the following type:</p><pre><code class="language-julia hljs">struct Foo{T}
    x::Vector{T}
    y::Vector{T}
    function Foo(x::Vector{T}, y::Vector{T}) where {T}
        @assert length(x) == length(y)
        return new{T}(x, y)
    end
end</code></pre><p>Here, the value returned by <code>_add_to_primal</code> will satisfy the invariant asserted in the inner constructor for <code>Foo</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L760-L784">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake._diff" href="#Mooncake._diff"><code>Mooncake._diff</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_diff(p::P, q::P) where {P}</code></pre><p>Required for testing.</p><p>Computes the difference between <code>p</code> and <code>q</code>, which <em>must</em> be of the same type, <code>P</code>. Returns a tangent of type <code>tangent_type(P)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L912-L919">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake._dot" href="#Mooncake._dot"><code>Mooncake._dot</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_dot(t::T, s::T)::Float64 where {T}</code></pre><p>Required for testing. Should be defined for all standard tangent types.</p><p>Inner product between tangents <code>t</code> and <code>s</code>. Must return a <code>Float64</code>. Always available because all tangent types correspond to finite-dimensional vector spaces.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L733-L741">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake._scale" href="#Mooncake._scale"><code>Mooncake._scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_scale(a::Float64, t::T) where {T}</code></pre><p>Required for testing. Should be defined for all standard tangent types.</p><p>Multiply tangent <code>t</code> by scalar <code>a</code>. Always possible because any given tangent type must correspond to a vector field. Not using <code>*</code> in order to avoid piracy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/tangents.jl#L701-L709">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.TestUtils.populate_address_map" href="#Mooncake.TestUtils.populate_address_map"><code>Mooncake.TestUtils.populate_address_map</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">populate_address_map(primal, tangent)</code></pre><p>Constructs an empty <code>AddressMap</code> and calls <code>populate_address_map_internal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/test_utils.jl#L307-L311">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.fdata_type" href="#Mooncake.fdata_type"><code>Mooncake.fdata_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdata_type(T)</code></pre><p>Returns the type of the forwards data associated to a tangent of type <code>T</code>.</p><p><strong>Extended help</strong></p><p>Rules in Mooncake.jl do not operate on tangents directly. Rather, functionality is defined to split each tangent into two components, that we call <em>fdata</em> (forwards-pass data) and <em>rdata</em> (reverse-pass data). In short, any component of a tangent which is identified by its address (e.g. a <code>mutable struct</code>s or an <code>Array</code>) gets passed around on the forwards-pass of AD and is incremented in-place on the reverse-pass, while components of tangents identified by their value get propagated and accumulated only on the reverse-pass.</p><p>Given a tangent type <code>T</code>, you can find out what type its fdata and rdata must be with <code>fdata_type(T)</code> and <code>rdata_type(T)</code> respectively. A consequence of this is that there is exactly one valid fdata type and rdata type for each primal type.</p><p>Given a tangent <code>t</code>, you can get its fdata and rdata using <code>f = fdata(t)</code> and <code>r = rdata(t)</code> respectively. <code>f</code> and <code>r</code> can be re-combined to recover the original tangent using the binary version of <code>tangent</code>: <code>tangent(f, r)</code>. It must always hold that</p><pre><code class="language-julia hljs">tangent(fdata(t), rdata(t)) === t</code></pre><p>The need for all of this is explained in the docs, but for now it suffices to consider our running examples again, and to see what their fdata and rdata look like.</p><p><strong>Int</strong></p><p><code>Int</code>s are non-differentiable types, so there is nothing to pass around on the forwards- or reverse-pass. Therefore</p><pre><code class="language-julia-repl hljs">julia&gt; fdata_type(tangent_type(Int)), rdata_type(tangent_type(Int))
(NoFData, NoRData)</code></pre><p><strong>Float64</strong></p><p>The tangent type of <code>Float64</code> is <code>Float64</code>. <code>Float64</code>s are identified by their value / have no fixed address, so</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(Float64), rdata_type(Float64))
(NoFData, Float64)</code></pre><p><strong>Vector{Float64}</strong></p><p>The tangent type of <code>Vector{Float64}</code> is <code>Vector{Float64}</code>. A <code>Vector{Float64}</code> is identified by its address, so</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(Vector{Float64}), rdata_type(Vector{Float64}))
(Vector{Float64}, NoRData)</code></pre><p><strong>Tuple{Float64, Vector{Float64}, Int}</strong></p><p>This is an example of a type which has both fdata and rdata. The tangent type for <code>Tuple{Float64, Vector{Float64}, Int}</code> is <code>Tuple{Float64, Vector{Float64}, NoTangent}</code>. <code>Tuple</code>s have no fixed memory address, so we interogate each field on its own. We have already established the fdata and rdata types for each element, so we recurse to obtain:</p><pre><code class="language-julia-repl hljs">julia&gt; T = tangent_type(Tuple{Float64, Vector{Float64}, Int})
Tuple{Float64, Vector{Float64}, NoTangent}

julia&gt; (fdata_type(T), rdata_type(T))
(Tuple{NoFData, Vector{Float64}, NoFData}, Tuple{Float64, NoRData, NoRData})</code></pre><p>The zero tangent for <code>(5.0, [5.0])</code> is <code>t = (0.0, [0.0])</code>. <code>fdata(t)</code> returns <code>(NoFData(), [0.0])</code>, where the second element is <code>===</code> to the second element of <code>t</code>. <code>rdata(t)</code> returns <code>(0.0, NoRData())</code>. In this example, <code>t</code> contains a mixture of data, some of which is identified by its value, and some of which is identified by its address, so there is some fdata and some rdata.</p><p><strong>Structs</strong></p><p>Structs are handled in more-or-less the same way as <code>Tuple</code>s, albeit with the possibility of undefined fields needing to be explicitly handled. For example, a struct such as</p><pre><code class="language-julia-repl hljs">julia&gt; struct Foo
           x::Float64
           y
           z::Int
       end</code></pre><p>has tangent type</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Foo)
Tangent{@NamedTuple{x::Float64, y, z::NoTangent}}</code></pre><p>Its fdata and rdata are given by special <code>FData</code> and <code>RData</code> types:</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(tangent_type(Foo)), rdata_type(tangent_type(Foo)))
(Mooncake.FData{@NamedTuple{x::NoFData, y, z::NoFData}}, Mooncake.RData{@NamedTuple{x::Float64, y, z::NoRData}})</code></pre><p>Practically speaking, <code>FData</code> and <code>RData</code> both have the same structure as <code>Tangent</code>s and are just used in different contexts.</p><p><strong>Mutable Structs</strong></p><p>The fdata for a <code>mutable struct</code>s is its tangent, and it has no rdata. This is because <code>mutable struct</code>s have fixed memory addresses, and can therefore be incremented in-place. For example,</p><pre><code class="language-julia-repl hljs">julia&gt; mutable struct Bar
           x::Float64
           y
           z::Int
       end</code></pre><p>has tangent type</p><pre><code class="language-julia-repl hljs">julia&gt; tangent_type(Bar)
MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}</code></pre><p>and fdata / rdata types</p><pre><code class="language-julia-repl hljs">julia&gt; (fdata_type(tangent_type(Bar)), rdata_type(tangent_type(Bar)))
(MutableTangent{@NamedTuple{x::Float64, y, z::NoTangent}}, NoRData)</code></pre><p><strong>Primitive Types</strong></p><p>As with tangents, each primitive type must specify what its fdata and rdata is. See specific examples for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/fwds_rvs_data.jl#L33-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.rdata_type" href="#Mooncake.rdata_type"><code>Mooncake.rdata_type</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rdata_type(T)</code></pre><p>Returns the type of the reverse data of a tangent of type T.</p><p><strong>Extended help</strong></p><p>See extended help in <a href="#Mooncake.fdata_type"><code>fdata_type</code></a> docstring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/fwds_rvs_data.jl#L414-L422">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.fdata" href="#Mooncake.fdata"><code>Mooncake.fdata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fdata(t)::fdata_type(typeof(t))</code></pre><p>Extract the forwards data from tangent <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/fwds_rvs_data.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.rdata" href="#Mooncake.rdata"><code>Mooncake.rdata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rdata(t)::rdata_type(typeof(t))</code></pre><p>Extract the reverse data from tangent <code>t</code>.</p><p><strong>Extended help</strong></p><p>See extended help section of <a href="#Mooncake.fdata_type">fdata_type</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/fwds_rvs_data.jl#L502-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Mooncake.uninit_fdata" href="#Mooncake.uninit_fdata"><code>Mooncake.uninit_fdata</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uninit_fdata(p)</code></pre><p>Equivalent to <code>fdata(uninit_tangent(p))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/compintell/Mooncake.jl/blob/7fb2ccf2a09facc9672ff54b3850113e90b8b2d9/src/fwds_rvs_data.jl#L268-L272">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../developer_tools/">« Developer Tools</a><a class="docs-footer-nextpage" href="../forwards_mode_design/">Forwards-Mode Design »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 6 March 2025 13:35">Thursday 6 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
