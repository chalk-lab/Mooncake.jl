<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Towards AD in Julia: Composition of Rules · Mooncake.jl</title><meta name="title" content="Towards AD in Julia: Composition of Rules · Mooncake.jl"/><meta property="og:title" content="Towards AD in Julia: Composition of Rules · Mooncake.jl"/><meta property="twitter:title" content="Towards AD in Julia: Composition of Rules · Mooncake.jl"/><meta name="description" content="Documentation for Mooncake.jl."/><meta property="og:description" content="Documentation for Mooncake.jl."/><meta property="twitter:description" content="Documentation for Mooncake.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Mooncake.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Mooncake.jl</a></li><li><a class="tocitem" href="../../tutorial/">Tutorial</a></li><li><span class="tocitem">Understanding Mooncake.jl</span><ul><li><a class="tocitem" href="../introduction/">Introduction</a></li><li><a class="tocitem" href="../algorithmic_differentiation/">Algorithmic Differentiation</a></li><li><a class="tocitem" href="../rule_system/">Mooncake.jl&#39;s Rule System</a></li><li class="is-active"><a class="tocitem" href>Towards AD in Julia: Composition of Rules</a><ul class="internal"><li><a class="tocitem" href="#A-Motivating-Example"><span>A Motivating Example</span></a></li><li><a class="tocitem" href="#Part-1:-Simple-Compositions-of-Pure-Functions"><span>Part 1: Simple Compositions of Pure Functions</span></a></li><li><a class="tocitem" href="#Part-2:-Computational-Graphs-of-Pure-Functions"><span>Part 2: Computational Graphs of Pure Functions</span></a></li><li><a class="tocitem" href="#Part-3:-Computational-Graphs-of-Mutating-Functions"><span>Part 3: Computational Graphs of Mutating Functions</span></a></li><li><a class="tocitem" href="#Part-4:-Computational-Graphs-of-Mutating-Functions-with-Aliasing"><span>Part 4: Computational Graphs of Mutating Functions with Aliasing</span></a></li></ul></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="../../utilities/defining_rules/">Defining Rules</a></li><li><a class="tocitem" href="../../utilities/debug_mode/">Debug Mode</a></li><li><a class="tocitem" href="../../utilities/debugging_and_mwes/">Debugging and MWEs</a></li></ul></li><li><span class="tocitem">Developer Documentation</span><ul><li><a class="tocitem" href="../../developer_documentation/running_tests_locally/">Running Tests Locally</a></li><li><a class="tocitem" href="../../developer_documentation/developer_tools/">Developer Tools</a></li><li><a class="tocitem" href="../../developer_documentation/forwards_mode_design/">Forwards-Mode Design</a></li><li><a class="tocitem" href="../../developer_documentation/misc_internals_notes/">Misc. Internals Notes</a></li><li><a class="tocitem" href="../../developer_documentation/internal_docstrings/">Internal Docstrings</a></li></ul></li><li><a class="tocitem" href="../../known_limitations/">Known Limitations</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Understanding Mooncake.jl</a></li><li class="is-active"><a href>Towards AD in Julia: Composition of Rules</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Towards AD in Julia: Composition of Rules</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/compintell/Mooncake.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/compintell/Mooncake.jl/blob/main/docs/src/understanding_mooncake/what_programme_are_you_differentiating.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Towards-AD-in-Julia:-Composition-of-Rules"><a class="docs-heading-anchor" href="#Towards-AD-in-Julia:-Composition-of-Rules">Towards AD in Julia: Composition of Rules</a><a id="Towards-AD-in-Julia:-Composition-of-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Towards-AD-in-Julia:-Composition-of-Rules" title="Permalink"></a></h1><p>In <a href="../rule_system/#Mooncake.jl&#39;s-Rule-System">Mooncake.jl&#39;s Rule System</a> we provide a mathematical model for a <em>single</em> Julia <code>function</code>, and state what a rule to differentiate it in reverse-mode must do. However, we do not explain how to algorithmically derive rules for compositions of Julia <code>function</code>s, each of which already has a rule. The purpose of this section is to move towards this.</p><h2 id="A-Motivating-Example"><a class="docs-heading-anchor" href="#A-Motivating-Example">A Motivating Example</a><a id="A-Motivating-Example-1"></a><a class="docs-heading-anchor-permalink" href="#A-Motivating-Example" title="Permalink"></a></h2><p>By the end of this section we will understand why, for the following function:</p><pre><code class="language-julia hljs">function f(x, y)
    a = g(x)
    b = h(a, y)
    return b
end</code></pre><p>the following rule is a correct implementation of reverse-mode AD for it:</p><pre><code class="language-julia hljs">function r(f, x, y)
    a, adj_g = r(g, x)
    b, adj_h = r(h, a, x, y)
    function adj_f(db)
        _, da, dx, dy = adj_h(db)
        _, dx2 = adj_g(da)
        dx = dx + dx2
        return NoRData(), dx, dy
    end
    return b, adj_f
end</code></pre><p>This is important because the above rule essentially does the following:</p><ol><li>fowards-pass: replace calls to rules.</li><li>reverse-pass: run adjoints in reverse order, adding together rdata when a variable is used multiple times.</li></ol><p>This way of writing rules is the essence of the &quot;A&quot; in &quot;AD&quot;. This page is therefore dedicated to building up to this example via a sequence of increasingly general examples. Once we have this, extending it to a <em>very</em> general class of Julia functions is comparatively straightforward.</p><p>We shall adopt the following approach to each problem:</p><ol><li>specify class of <code>function</code>s,</li><li>specify class of differentiable functions used to model these <code>function</code>s,</li><li>specify how to find the adjoints of this differentiable model, and</li><li>describe a rule system which implements these adjoints.</li></ol><p>At a high level, you can think of this approach as first &quot;mathematising&quot; the problem, applying the techniques developed in <a href="../algorithmic_differentiation/#Algorithmic-Differentiation">Algorithmic Differentiation</a> to determine what it is that AD must do, and then providing an outline for implementing this model as a computer programme.</p><h2 id="Part-1:-Simple-Compositions-of-Pure-Functions"><a class="docs-heading-anchor" href="#Part-1:-Simple-Compositions-of-Pure-Functions">Part 1: Simple Compositions of Pure Functions</a><a id="Part-1:-Simple-Compositions-of-Pure-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Part-1:-Simple-Compositions-of-Pure-Functions" title="Permalink"></a></h2><p>For this class of <code>function</code>s, the translation between the Julia <code>function</code> and differentiable function used to model it is almost trivial. We ask for patience, and promise that the modelling task will become more interesting shortly!</p><h3 id="function-Class"><a class="docs-heading-anchor" href="#function-Class"><code>function</code> Class</a><a id="function-Class-1"></a><a class="docs-heading-anchor-permalink" href="#function-Class" title="Permalink"></a></h3><p>To start with, let us consider only <code>function</code>s which are, pure (free of externally-visible side effects), unary, and don&#39;t contain any data themselves (e.g. no closures or callable <code>struct</code>s). For example, consider:</p><h4 id="g:"><a class="docs-heading-anchor" href="#g:"><code>g</code>:</a><a id="g:-1"></a><a class="docs-heading-anchor-permalink" href="#g:" title="Permalink"></a></h4><p><code>g(x::Vector{Float64}) = 2x</code> TODO: pick a non-linear example!!!!</p><h4 id="h:"><a class="docs-heading-anchor" href="#h:"><code>h</code>:</a><a id="h:-1"></a><a class="docs-heading-anchor-permalink" href="#h:" title="Permalink"></a></h4><p><code>h(x::Matrix{Float64}) = sum(x)</code>.</p><h4 id="Composition"><a class="docs-heading-anchor" href="#Composition">Composition</a><a id="Composition-1"></a><a class="docs-heading-anchor-permalink" href="#Composition" title="Permalink"></a></h4><p>Let <code>f</code> be the composition of <code>f_1</code>, ..., <code>f_N</code>, a collection of <code>N</code> Julia <code>function</code>s which are pure and unary. This might be implemented as <code>f(x) := f_N ∘ ... ∘ f_1</code>, or perhaps</p><pre><code class="language-julia hljs">function f(x)
    x_1 = x
    x_2 = f_1(x_1)
    ...
    return f_N(x_N)
end</code></pre><p>There are many ways to implement this function.</p><h3 id="Differentiable-Model"><a class="docs-heading-anchor" href="#Differentiable-Model">Differentiable Model</a><a id="Differentiable-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Differentiable-Model" title="Permalink"></a></h3><p>We propose to represent any <code>function</code> <code>f</code> in this class by a differentiable function <span>$f : \mathcal{X} \to \mathcal{Y}$</span>.</p><h4 id="g:-2"><a class="docs-heading-anchor" href="#g:-2"><code>g</code>:</a><a class="docs-heading-anchor-permalink" href="#g:-2" title="Permalink"></a></h4><p>Let <span>$\mathcal{X} = \mathcal{Y} =: \mathbb{R}^D$</span> where <span>$D$</span> is <code>length(x)</code>, and <span>$f(x) := 2x$</span>.</p><h4 id="h:-2"><a class="docs-heading-anchor" href="#h:-2"><code>h</code>:</a><a class="docs-heading-anchor-permalink" href="#h:-2" title="Permalink"></a></h4><p>Let <span>$\mathcal{X} := \mathbb{R}^{P \times Q}$</span>, and <span>$\mathcal{Y} := \mathbb{R}$</span>, where <span>$P$</span> and <span>$Q$</span> are the number of rows and columns in <code>x</code>, and <span>$f(x) := \sum_{p,q} x_{p,q}$</span>.</p><h4 id="Composition:"><a class="docs-heading-anchor" href="#Composition:">Composition:</a><a id="Composition:-1"></a><a class="docs-heading-anchor-permalink" href="#Composition:" title="Permalink"></a></h4><p>Let <span>$f_n : \mathcal{X}_n \to \mathcal{X}_{n+1}$</span> be the differentiable model for <code>f_n</code>. Then the differentiable model <span>$f : \mathcal{X} \to \mathcal{Y}$</span> for <code>f</code> is <span>$f := f_N \circ \dots \circ f_1$</span>, with <span>$\mathcal{X} := \mathcal{X}_1$</span> and <span>$\mathcal{Y} := \mathcal{X}_{N+1}$</span>.</p><h3 id="Adjoints-of-Model"><a class="docs-heading-anchor" href="#Adjoints-of-Model">Adjoints of Model</a><a id="Adjoints-of-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Adjoints-of-Model" title="Permalink"></a></h3><p>You can apply the tools developed in <a href="../algorithmic_differentiation/#Algorithmic-Differentiation">Algorithmic Differentiation</a> to figure out the adjoints of <code>g</code> and <code>h</code>. The adjoint of <code>f</code> is also given there. Let <span>$D f_n [x_n]^\ast$</span> be the adjoint of the derivative of <span>$f_n$</span> at <span>$x_n$</span>, then the adjoint of <span>$f$</span> at <span>$x$</span> is just</p><p class="math-container">\[D f [x]^\ast = D f_1 [x_1]^\ast \circ \dots \circ D f_N [x_N]^\ast.\]</p><h3 id="Rules"><a class="docs-heading-anchor" href="#Rules">Rules</a><a id="Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Rules" title="Permalink"></a></h3><p>For this simple class of functions, a simple rule system will do. Recall that you should be satisfied with the rules below if you believe that the adjoint <code>function</code>s that they return faithfully implement the adjoints of the corresponding differentiable functions derived above.<sup class="footnote-reference"><a id="citeref-implementing_mathematics_on_a_computer" href="#footnote-implementing_mathematics_on_a_computer">[implementing_mathematics_on_a_computer]</a></sup></p><h4 id="g:-3"><a class="docs-heading-anchor" href="#g:-3"><code>g</code>:</a><a class="docs-heading-anchor-permalink" href="#g:-3" title="Permalink"></a></h4><pre><code class="language-julia hljs">function rrule(::typeof(g), x::Vector{Float64})
    g_adjoint(ȳ::Vector{Float64}) = 2ȳ
    return g(x), g_adjoint
end</code></pre><h4 id="h:-3"><a class="docs-heading-anchor" href="#h:-3"><code>h</code>:</a><a class="docs-heading-anchor-permalink" href="#h:-3" title="Permalink"></a></h4><pre><code class="language-julia hljs">function rrule(::typeof(h), x::Matrix{Float64})
    h_adjoint(ȳ::Float64) = fill(ȳ, size(x))
    return h(x), h_adjoint
end</code></pre><h4 id="Composition:-2"><a class="docs-heading-anchor" href="#Composition:-2">Composition:</a><a class="docs-heading-anchor-permalink" href="#Composition:-2" title="Permalink"></a></h4><pre><code class="language-julia hljs">function rrule(::typeof(f), x)
    x_1 = x
    x_2, f_1_adjoint = rrule(f_1, x_1)
    ...
    y, f_N_adjoint = rrule(f_N, x_N)
    function f_adjoint(ȳ)
        x̄_N = f_N_adjoint(ȳ)
        ...
        x̄_1 = f_1_adjoint(x̄_2)
        x̄ = x̄_1
        return x̄
    end
    return y, f_adjoint
end</code></pre><h2 id="Part-2:-Computational-Graphs-of-Pure-Functions"><a class="docs-heading-anchor" href="#Part-2:-Computational-Graphs-of-Pure-Functions">Part 2: Computational Graphs of Pure Functions</a><a id="Part-2:-Computational-Graphs-of-Pure-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Part-2:-Computational-Graphs-of-Pure-Functions" title="Permalink"></a></h2><h2 id="Part-3:-Computational-Graphs-of-Mutating-Functions"><a class="docs-heading-anchor" href="#Part-3:-Computational-Graphs-of-Mutating-Functions">Part 3: Computational Graphs of Mutating Functions</a><a id="Part-3:-Computational-Graphs-of-Mutating-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Part-3:-Computational-Graphs-of-Mutating-Functions" title="Permalink"></a></h2><h2 id="Part-4:-Computational-Graphs-of-Mutating-Functions-with-Aliasing"><a class="docs-heading-anchor" href="#Part-4:-Computational-Graphs-of-Mutating-Functions-with-Aliasing">Part 4: Computational Graphs of Mutating Functions with Aliasing</a><a id="Part-4:-Computational-Graphs-of-Mutating-Functions-with-Aliasing-1"></a><a class="docs-heading-anchor-permalink" href="#Part-4:-Computational-Graphs-of-Mutating-Functions-with-Aliasing" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-implementing_mathematics_on_a_computer"><a class="tag is-link" href="#citeref-implementing_mathematics_on_a_computer">implementing_mathematics_on_a_computer</a>put differently, suppose that someone wrote down some equations in a paper or textbook, and gave you a piece of code which they claim is an implementation of these equations (e.g. a neural network, a probabilistic model, an ODE, etc). Under what conditions would you be satisfied that the implementation was correct? We all do this in informal ways all of the time. I propose that you apply the same set of standards here: we have written down some equations for the adjoints, and are claiming that our rule system is an implementation of these. The fact that we arrived at this set of equations by modelling a computer programme is neither here nor there for this step of the process.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../rule_system/">« Mooncake.jl&#39;s Rule System</a><a class="docs-footer-nextpage" href="../../utilities/defining_rules/">Defining Rules »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Thursday 13 February 2025 10:57">Thursday 13 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
