<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Known Limitations · Tapir.jl</title><meta name="title" content="Known Limitations · Tapir.jl"/><meta property="og:title" content="Known Limitations · Tapir.jl"/><meta property="twitter:title" content="Known Limitations · Tapir.jl"/><meta name="description" content="Documentation for Tapir.jl."/><meta property="og:description" content="Documentation for Tapir.jl."/><meta property="twitter:description" content="Documentation for Tapir.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Tapir.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Tapir.jl</a></li><li><span class="tocitem">Understanding Tapir.jl</span><ul><li><a class="tocitem" href="../understanding_intro/">Introduction</a></li><li><a class="tocitem" href="../algorithmic_differentiation/">Algorithmic Differentiation</a></li><li><a class="tocitem" href="../mathematical_interpretation/">Tapir.jl&#39;s Rule System</a></li></ul></li><li class="is-active"><a class="tocitem" href>Known Limitations</a><ul class="internal"><li><a class="tocitem" href="#Mutation-of-Global-Variables"><span>Mutation of Global Variables</span></a></li><li><a class="tocitem" href="#Circular-References"><span>Circular References</span></a></li><li><a class="tocitem" href="#Tangent-Generation-and-Pointers"><span>Tangent Generation and Pointers</span></a></li></ul></li><li><a class="tocitem" href="../safe_mode/">Safe Mode</a></li><li><a class="tocitem" href="../debugging_and_mwes/">Debugging and MWEs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Known Limitations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Known Limitations</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/compintell/Tapir.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/compintell/Tapir.jl/blob/main/docs/src/known_limitations.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Known-Limitations"><a class="docs-heading-anchor" href="#Known-Limitations">Known Limitations</a><a id="Known-Limitations-1"></a><a class="docs-heading-anchor-permalink" href="#Known-Limitations" title="Permalink"></a></h1><p>Tapir.jl has a number of known qualitative limitations, which we document here.</p><h2 id="Mutation-of-Global-Variables"><a class="docs-heading-anchor" href="#Mutation-of-Global-Variables">Mutation of Global Variables</a><a id="Mutation-of-Global-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Mutation-of-Global-Variables" title="Permalink"></a></h2><p>While great care is taken in this package to prevent silent errors, this is one edge case that we have yet to provide a satisfactory solution for. Consider a function of the form:</p><pre><code class="language-julia-repl hljs">julia&gt; const x = Ref(1.0);

julia&gt; function foo(y::Float64)
           x[] = y
           return x[]
       end
foo (generic function with 1 method)</code></pre><p><code>x</code> is a global variable (if you refer to it in your code, it appears as a <code>GlobalRef</code> in the AST or lowered code). For some technical reasons that are beyond the scope of this section, this package cannot propagate gradient information through <code>x</code>. <code>foo</code> is the identity function, so it should have gradient <code>1.0</code>. However, if you differentiate this example, you&#39;ll see:</p><pre><code class="language-julia-repl hljs">julia&gt; rule = Tapir.build_rrule(foo, 2.0);

julia&gt; Tapir.value_and_gradient!!(rule, foo, 2.0)
(2.0, (NoTangent(), 0.0))</code></pre><p>Observe that while it has correctly computed the identity function, the gradient is zero.</p><p>The takehome: do not attempt to differentiate functions which modify global state. Uses of globals which does not involve mutating them is fine though.</p><h2 id="Circular-References"><a class="docs-heading-anchor" href="#Circular-References">Circular References</a><a id="Circular-References-1"></a><a class="docs-heading-anchor-permalink" href="#Circular-References" title="Permalink"></a></h2><p>To a large extent, Tapir.jl does not presently support circular references in an automatic fashion. It is generally possible to hand-write solutions, so we explain some of the problems here, and the general approach to resolving them.</p><h3 id="Tangent-Types"><a class="docs-heading-anchor" href="#Tangent-Types">Tangent Types</a><a id="Tangent-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Tangent-Types" title="Permalink"></a></h3><p><em><strong>The Problem</strong></em></p><p>Suppose that you have a type such as:</p><pre><code class="language-julia hljs">mutable struct A
    x::Float64
    a::A
    function A(x::Float64)
        a = new(x)
        a.a = a
        return a
    end
end</code></pre><p>This is a fairly canonical example of a self-referential type. There are a couple of things which will not work with it out-of-the-box. <code>tangent_type(A)</code> will produce a stack overflow error. To see this, note that it will in effect try to produce a tangent of type <code>Tangent{Tuple{tangent_type(A)}}</code> – the circular dependency on the <code>tangent_type</code> function causes real problems here.</p><p><em><strong>The Solution</strong></em></p><p>In order to resolve this, you need to produce a tangent type by hand. You might go with something like</p><pre><code class="language-julia hljs">mutable struct TangentForA
    x::Float64 # tangent type for Float64 is Float64
    a::TangentForA
    function TangentForA(x::Float64)
        a = new(x)
        a.a = a
        return a
    end
end</code></pre><p>The point here is that you can manually resolve the circular dependency using a data structure which mimics the primal type. You will, however, need to implement similar methods for <code>zero_tangent</code>, <code>randn_tangent</code>, etc, and presumably need to implement additional <code>getfield</code> and <code>setfield</code> rules which are specific to this type.</p><h3 id="Circular-References-in-General"><a class="docs-heading-anchor" href="#Circular-References-in-General">Circular References in General</a><a id="Circular-References-in-General-1"></a><a class="docs-heading-anchor-permalink" href="#Circular-References-in-General" title="Permalink"></a></h3><p><em><strong>The Problem</strong></em></p><p>Consider a type of the form</p><pre><code class="language-julia hljs">mutable struct Foo
    x
    Foo() = new()
end</code></pre><p>In this instance, <code>tangent_type</code> will work fine because <code>Foo</code> does not directly reference itself in its definition. Moreover, general uses of <code>Foo</code> will be fine.</p><p>However, it&#39;s possible to construct an instance of <code>Foo</code> with a circular reference:</p><pre><code class="language-julia hljs">f = Foo()
f.x = f</code></pre><p>This is actually fine provided we never attempt to call <code>zero_tangent</code> / <code>randn_tangent</code> / similar functionality on <code>f</code> once we&#39;ve set its <code>x</code> field to itself. If we attempt to call such a function, we&#39;ll find ourselves with a stack overflow.</p><p><em><strong>The Solution</strong></em> This is a little tricker to handle. You could specialise <code>zero_tangent</code> etc for <code>Foo</code>, but this is something of a pain. Fortunately, it seems to be incredibly rare that this is ever a problem in practice. If we gain evidence that this <em>is</em> often a problem in practice, we&#39;ll look into supporting <code>zero_tangent</code> etc automatically for this case.</p><h2 id="Tangent-Generation-and-Pointers"><a class="docs-heading-anchor" href="#Tangent-Generation-and-Pointers">Tangent Generation and Pointers</a><a id="Tangent-Generation-and-Pointers-1"></a><a class="docs-heading-anchor-permalink" href="#Tangent-Generation-and-Pointers" title="Permalink"></a></h2><p><em><strong>The Problem</strong></em></p><p>In many use cases, a pointer provides the address of the start of a block of memory which has been allocated to e.g. store an array. However, we cannot get any of this context from the pointer itself – by just looking at a pointer, I cannot know whether its purpose is to refer to the start of a large block of memory, some proportion of the way through a block of memory, or even to keep track of a single address.</p><p>Recall that the tangent to a pointer is another pointer:</p><pre><code class="language-julia-repl hljs">julia&gt; Tapir.tangent_type(Ptr{Float64})
Ptr{Float64}</code></pre><p>Plainly I cannot implement a method of <code>zero_tangent</code> for <code>Ptr{Float64}</code> because I don&#39;t know how much memory to allocate.</p><p>This is, however, fine if a pointer appears half way through a function, having been derived from another data structure. e.g.</p><pre><code class="language-julia hljs">function foo(x::Vector{Float64})
    p = pointer(x, 2)
    return unsafe_load(p)
end

rule = build_rrule(get_tapir_interpreter(), Tuple{typeof(foo), Vector{Float64}})
Tapir.value_and_gradient!!(rule, foo, [5.0, 4.0])

# output
(4.0, (NoTangent(), [0.0, 1.0]))</code></pre><p><em><strong>The Solution</strong></em></p><p>This is only really a problem for tangent / fdata / rdata generation functionality, such as <code>zero_tangent</code>. As a work-around, AD testing functionality permits users to pass in <code>CoDual</code>s. So if you are testing something involving a pointer, you will need to construct its tangent yourself, and pass a <code>CoDual</code> to e.g. <code>Tapir.TestUtils.test_rule</code>.</p><p>While pointers tend to be a low-level implementation detail in Julia code, you could in principle actually be interested in differentiating a function of a pointer. In this case, you will not be able to use <code>Tapir.value_and_gradient!!</code> as this requires the use of <code>zero_tangent</code>. Instead, you will need to use lower-level (internal) functionality, such as <code>Tapir.__value_and_gradient!!</code>, or use the rule interface directly.</p><p>Honestly, your best bet is just to avoid differentiating functions whose arguments are pointers if you can.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../mathematical_interpretation/">« Tapir.jl&#39;s Rule System</a><a class="docs-footer-nextpage" href="../safe_mode/">Safe Mode »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Thursday 12 September 2024 09:55">Thursday 12 September 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
