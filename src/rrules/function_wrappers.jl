# Type used to represent tangents of `FunctionWrapper`s. Also used to represent its fdata
# because `FunctionWrapper`s are mutable types.
mutable struct FunctionWrapperTangent{Tfwds_oc}
    fwds_wrapper::Tfwds_oc
    dobj_ref::Ref
end

function _construct_types(R, A)

    # Convert signature into a tuple of types.
    primal_arg_types = (A.parameters..., )

    # Signature and OpaqueClosure type for reverse pass.
    rvs_sig = Tuple{rdata_type(tangent_type(R))}
    primal_rdata_sig = Tuple{map(rdata_type âˆ˜ tangent_type, primal_arg_types)...}
    pb_ret_type = Tuple{NoRData, NoRData, primal_rdata_sig.parameters...}
    rvs_oc_type = Core.OpaqueClosure{rvs_sig, pb_ret_type}

    # Signature and OpaqueClosure type for forwards pass.
    fwd_sig = Tuple{map(fcodual_type, primal_arg_types)...}
    fwd_oc_type = Core.OpaqueClosure{fwd_sig, Tuple{fcodual_type(R), rvs_oc_type}}
    return fwd_oc_type, rvs_oc_type, fwd_sig, rvs_sig
end

function tangent_type(::Type{FunctionWrapper{R, A}}) where {R, A<:Tuple}
    return FunctionWrapperTangent{_construct_types(R, A)[1]}
end

import .TestUtils: has_equal_data
has_equal_data(p::P, q::P) where {P<:FunctionWrapper} = has_equal_data(p.obj, q.obj)
function has_equal_data(t::T, s::T) where {T<:FunctionWrapperTangent}
    return has_equal_data(t.dobj_ref, s.dobj_ref)
end

function _function_wrapper_tangent(R, obj::Tobj, A, dobj) where {Tobj}

    # Analyse types.
    _, _, fwd_sig, rvs_sig = _construct_types(R, A)

    dobj_ref = Ref{tangent_type(Tobj)}(dobj)
    set_tangent_field!(obj_ref_codual.dx, :x, obj_tangent)

    # Construct a rule for `_eval` applied to obj and its arguments.
    rule = build_rrule(Tuple{Tobj, A.parameters...})

    # Construct stack which can hold pullbacks generated by `rule`. The forwards-pass will
    # run `rule` and push the pullback it returns in this. The reverse-pass will pop it and
    # run it.
    pb_stack = Stack{pullback_type(typeof(rule), (Tobj, A.parameters...))}()

    # Construct reverse-pass. Note: this closes over `pb_stack`.
    run_rvs_pass = Base.Experimental.@opaque rvs_sig dy -> pop!(pb_stack)(dy)

    # Construct fowards-pass. Note: this closes over the reverse-pass and `pb_stack`.
    run_fwds_pass = Base.Experimental.@opaque fwd_sig (x...) -> begin
        y, pb = rule(CoDual(obj, fdata()), x...)
        push!(pb_stack, pb)
        return y, run_rvs_pass
    end

    t = FunctionWrapperTangent(run_fwds_pass, obj_ref_codual)
    return t, obj_ref_codual
end

function zero_tangent_internal(
    p::FunctionWrapper{R, A}, stackdict::Union{Nothing, IdDict}
) where {R, A}

    # If we've seen this primal before, then we must return that tangent.
    haskey(stackdict, p) && return stackdict[p]::T

    # We have not seen this primal before, create it and log it.
    obj_tangent = zero_tangent_internal(p.obj[], stackdict)
    t, _ = _function_wrapper_tangent(R, p.obj[], A, obj_tangent)
    stackdict === nothing || setindex!(stackdict, t, p)
    return t
end

function randn_tangent_internal(
    rng::AbstractRNG, p::FunctionWrapper{R, A}, stackdict::Union{Nothing, IdDict}
) where {R, A}

    # If we've seen this primal before, then we must return that tangent.
    haskey(stackdict, p) && return stackdict[p]::T

    # We have not seen this primal before, create it and log it.
    obj_tangent = randn_tangent_internal(rng, p.obj[], stackdict)
    t, _ = _function_wrapper_tangent(R, p.obj[], A, obj_tangent)
    stackdict === nothing || setindex!(stackdict, t, p)
    return t
end

increment!!(t::FunctionWrapperTangent, s::FunctionWrapperTangent) = t

set_to_zero!!(t::FunctionWrapperTangent) = t

_add_to_primal(p::FunctionWrapper, t::FunctionWrapperTangent, unsafe::Bool) = p

function _diff(p::P, q::P) where {P<:FunctionWrapper}
    return tangent_type(P)(p, CoDual(Ref(p), nothing))
end

_dot(t::T, s::T) where {T<:FunctionWrapperTangent} = 0.0

_scale(a::Float64, t::FunctionWrapperTangent) = t

import .TestUtils: populate_address_map!, AddressMap
function populate_address_map!(m::AddressMap, p::FunctionWrapper, t::FunctionWrapperTangent)
    k = pointer_from_objref(p)
    v = pointer_from_objref(t)
    haskey(m, k) && (@assert m[k] == v)
    m[k] = v
    return m
end

fdata_type(T::Type{<:FunctionWrapperTangent}) = T
rdata_type(::Type{FunctionWrapperTangent}) = NoRData
tangent_type(F::Type{<:FunctionWrapperTangent}, ::Type{NoRData}) = F
tangent(f::FunctionWrapperTangent, ::NoRData) = f

_verify_fdata_value(p::FunctionWrapper, t::FunctionWrapperTangent) = nothing

@is_primitive MinimalCtx Tuple{Type{<:FunctionWrapper}, Any}
function rrule!!(::CoDual{Type{FunctionWrapper{R, A}}}, obj::CoDual{P}) where {R, A, P}
    t, obj_ref_codual = _function_wrapper_tangent(R, obj.x, A, zero_tangent(obj.x, obj.dx))
    function_wrapper_pb(::NoRData) = NoRData(), rdata(val(obj_ref_codual.dx.fields.x))
    return CoDual(FunctionWrapper{R, A}(obj.x), t), function_wrapper_pb
end

@is_primitive MinimalCtx Tuple{<:FunctionWrapper, Vararg}
function rrule!!(f::CoDual{<:FunctionWrapper}, x::Vararg{CoDual})
    y, pb = f.dx.fwds_wrapper(x...)
    function function_wrapper_eval_pb(dy)
        
        return pb(dy)[2:end]
    end
    return y, function_wrapper_eval_pb
end

function generate_hand_written_rrule!!_test_cases(rng_ctor, ::Val{:function_wrappers})
    test_cases = Any[
        (true, :none, nothing, FunctionWrapper{Float64, Tuple{Float64}}, sin),
        (true, :none, nothing, FunctionWrapper{Float64, Tuple{Float64}}(sin), 5.0),
    ]
    memory = Any[]
    return test_cases, memory
end

function generate_derived_rrule!!_test_cases(rng_ctor, ::Val{:function_wrappers})
    test_cases = Any[
        (
            false, :none, nothing,
            function(x, y)
                p = FunctionWrapper{Float64, Tuple{Float64}}(x -> x * y)
                out = 0.0
                for _ in 1:1_000
                    out += p(x)
                end
                return out
            end,
            5.0, 4.0,
        )
    ]    
    return test_cases, Any[]
end
